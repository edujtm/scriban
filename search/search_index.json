{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation See the Language document for a description of the language syntax. See the Built-in functions document for the list of the built-in functions. See the Runtime document for a description of the .NET runtime API to compile and run templates. See the Liquid support document for more details about the support of liquid templates. See my blog post \" Implementing a Text Templating Engine for .NET \" for some behind the scene details.","title":"Documentation"},{"location":"#documentation","text":"See the Language document for a description of the language syntax. See the Built-in functions document for the list of the built-in functions. See the Runtime document for a description of the .NET runtime API to compile and run templates. See the Liquid support document for more details about the support of liquid templates. See my blog post \" Implementing a Text Templating Engine for .NET \" for some behind the scene details.","title":"Documentation"},{"location":"benchmarks/","text":"Benchmarks Latest benchmark update: 07 March 2019 Note This is a micro benchmark, so results may vary vastly on use cases. The goal here is to demonstrate on a very simple example how the different engines behave Also, while Scriban is compared here to liquid and mustache like templating engines, you should keep in mind that language-wise, Scriban is allowing a lot more language constructions/expressions. The benchmark was performed on two aspects of the libraries: The Parser Benchmark : How long does it take to parse a template to a runtime representation? How much memory is used? The Rendering Benchmark : How long does it take to render a template with some input datas? How much memory is used? Libraries used in this comparison: Scriban (2.0.0-alpha-006), Syntax: Scriban Fluid (Fluid.Core.1.0.0-beta-9545), Syntax: Liquid based DotLiquid (2.0.298), Syntax: Liquid based Stubble (1.2.7), Syntax: Mustache+ based Nustache (1.16.0.8), Syntax: Mustache based Handlebars.NET (1.9.5), Syntax: Handlebars based Cottle (1.4.2), Syntax: Cottle We are also adding Razor (2.0.0), Syntax: Razor/C#, not in the charts and in the raw results. This is not a relevant comparison for the fact that it a not a \"end-user\" text templating engine (not safe) but it gives some insights about the best raw performance you can achieve with it for the rendering part, as it is generating very raw pre-compiler C# code that is basically issuing a bunch of WriteLiteral(text_as_is) , so you can't really do better here in terms of performance. For benchmarking, we are using the fantastic BenchmarkDotNet See the Scriban.Benchmark/Program.cs for details of the benchmark implementation. Overall results For the parser part: Scriban parser is 3x to 6x times faster compared to liquid based templating parsers Scriban parser takes 3x to 40x times less memory compared to other templating parsers If you look at Razor (which is again, not really fair), scriban is roughly 1000x times faster than Razor for parsing a template. Which is perfectly normal, as Razor is involving the full Roslyn/C# compiler here. It is taking a lot more memory...etc. But it is generating an ultra efficient renderer. For the rendering part: Scriban is 1.2x to x14 times faster than most of the other templating engines (Note that the new version of Fluid in this test is now 5-8% faster than Scriban on the rendering side) Scriban takes 3x to x65 times less memory compared to most of other templating engines In comparison to Razor, scriban is only 4-5 times slower than Razor, which is fairly honorable, considering how much raw is a compiled Razor template. In the following sections, you will find benchmark details. Parser Benchmarks The methodology is to compile the following Scriban script: < ul id = 'products' > {{ for product in products }} < li > < h2 > {{ product.name }} </ h2 > Only {{ product.price }} {{ product.description | string.truncate 15 }} </ li > {{ end }} </ ul > Or the equivalent Liquid script < ul id = 'products' > {% for product in products %} < li > < h2 > {{ product.name }} </ h2 > Only {{ product.price }} {{ product.description | truncate: 15 }} </ li > {% endfor %} </ ul > Or the pseudo-equivalent Mustache script: < ul id = 'products' > {{#products}} < li > < h2 > {{ name }} </ h2 > Only {{ price }} {{#truncate}}{{description}}{{/truncate}} </ li > {{/products}} </ ul > Or the pseudo-equivalent Cottle script: < ul id = 'products' > { for product in products: < li > < h2 > { product.Name } </ h2 > Only { product.Price } { string.truncate(product.Description, 15) } </ li > } </ ul > The raw results of the benchmarks are: // * Summary * BenchmarkDotNet=v0.11.4, OS=Windows 10.0.17134.590 (1803/April2018Update/Redstone4) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 | Method | Mean | Error | StdDev | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op | |-------------------------- |-------------:|------------:|------------:|------------:|------------:|------------:|--------------------:| | 'Scriban - Parser' | 10.20 us | 0.0327 us | 0.0306 us | 1.0376 | - | - | 4.29 KB | | 'DotLiquid - Parser' | 66.33 us | 0.3275 us | 0.2903 us | 3.7842 | - | - | 15.55 KB | | 'Stubble - Parser' | 14.21 us | 0.0864 us | 0.0721 us | 2.7618 | - | - | 11.37 KB | | 'Nustache - Parser' | 46.97 us | 0.4216 us | 0.3291 us | 6.5308 | - | - | 26.87 KB | | 'Handlebars.NET - Parser' | 1,645.16 us | 9.5167 us | 8.4363 us | 60.5469 | 1.9531 | - | 254.46 KB | | 'Cottle - Parser' | 11.20 us | 0.1197 us | 0.1000 us | 2.8229 | - | - | 11.57 KB | | 'Fluid - Parser' | 27.74 us | 0.5366 us | 0.7164 us | 7.0190 | - | - | 28.94 KB | | 'Razor - Parser' | 13,338.41 us | 264.8221 us | 644.6136 us | - | - | - | 3725.36 KB | About the results, we couldn't include Handlebars.NET in the following chart, as it is compiling to IL so it takes a lot more time to compile a template. Rendering Benchmarks The methodology is to use the previously compiled script and use it with a list of 500 Products to output a final string BenchmarkDotNet=v0.11.4, OS=Windows 10.0.17134.590 (1803/April2018Update/Redstone4) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 Method Mean Error StdDev Gen 0/1k Op Gen 1/1k Op Gen 2/1k Op Allocated Memory/Op Scriban 992.7 us 4.068 us 3.805 us 44.9219 17.5781 17.5781 213.04 KB ScribanAsync 4,268.2 us 18.446 us 16.352 us 23.4375 - - 212.93 KB DotLiquid 7,775.8 us 22.148 us 18.494 us 953.1250 93.7500 - 4050.74 KB Stubble 5,014.9 us 19.147 us 17.910 us 656.2500 - - 2796.59 KB Nustache 22,360.3 us 216.415 us 202.435 us 5562.5000 - - 22964.2 KB Handlebars 3,060.3 us 24.703 us 23.107 us 277.3438 31.2500 11.7188 1188.8 KB Cottle 2,039.5 us 11.350 us 10.617 us 218.7500 109.3750 11.7188 1329.83 KB Fluid 913.5 us 2.231 us 1.977 us 56.6406 20.5078 19.5313 245.3 KB Razor 314.3 us 3.107 us 2.595 us 58.1055 29.2969 19.0430 253.57 KB Note that for Stubble, It was not possible to match the behavior of the other engines, so it is including the parsing time (which is anyway insignificant compare to the rendering time in this particular case)","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"Latest benchmark update: 07 March 2019 Note This is a micro benchmark, so results may vary vastly on use cases. The goal here is to demonstrate on a very simple example how the different engines behave Also, while Scriban is compared here to liquid and mustache like templating engines, you should keep in mind that language-wise, Scriban is allowing a lot more language constructions/expressions. The benchmark was performed on two aspects of the libraries: The Parser Benchmark : How long does it take to parse a template to a runtime representation? How much memory is used? The Rendering Benchmark : How long does it take to render a template with some input datas? How much memory is used? Libraries used in this comparison: Scriban (2.0.0-alpha-006), Syntax: Scriban Fluid (Fluid.Core.1.0.0-beta-9545), Syntax: Liquid based DotLiquid (2.0.298), Syntax: Liquid based Stubble (1.2.7), Syntax: Mustache+ based Nustache (1.16.0.8), Syntax: Mustache based Handlebars.NET (1.9.5), Syntax: Handlebars based Cottle (1.4.2), Syntax: Cottle We are also adding Razor (2.0.0), Syntax: Razor/C#, not in the charts and in the raw results. This is not a relevant comparison for the fact that it a not a \"end-user\" text templating engine (not safe) but it gives some insights about the best raw performance you can achieve with it for the rendering part, as it is generating very raw pre-compiler C# code that is basically issuing a bunch of WriteLiteral(text_as_is) , so you can't really do better here in terms of performance. For benchmarking, we are using the fantastic BenchmarkDotNet See the Scriban.Benchmark/Program.cs for details of the benchmark implementation.","title":"Benchmarks"},{"location":"benchmarks/#overall-results","text":"For the parser part: Scriban parser is 3x to 6x times faster compared to liquid based templating parsers Scriban parser takes 3x to 40x times less memory compared to other templating parsers If you look at Razor (which is again, not really fair), scriban is roughly 1000x times faster than Razor for parsing a template. Which is perfectly normal, as Razor is involving the full Roslyn/C# compiler here. It is taking a lot more memory...etc. But it is generating an ultra efficient renderer. For the rendering part: Scriban is 1.2x to x14 times faster than most of the other templating engines (Note that the new version of Fluid in this test is now 5-8% faster than Scriban on the rendering side) Scriban takes 3x to x65 times less memory compared to most of other templating engines In comparison to Razor, scriban is only 4-5 times slower than Razor, which is fairly honorable, considering how much raw is a compiled Razor template. In the following sections, you will find benchmark details.","title":"Overall results"},{"location":"benchmarks/#parser-benchmarks","text":"The methodology is to compile the following Scriban script: < ul id = 'products' > {{ for product in products }} < li > < h2 > {{ product.name }} </ h2 > Only {{ product.price }} {{ product.description | string.truncate 15 }} </ li > {{ end }} </ ul > Or the equivalent Liquid script < ul id = 'products' > {% for product in products %} < li > < h2 > {{ product.name }} </ h2 > Only {{ product.price }} {{ product.description | truncate: 15 }} </ li > {% endfor %} </ ul > Or the pseudo-equivalent Mustache script: < ul id = 'products' > {{#products}} < li > < h2 > {{ name }} </ h2 > Only {{ price }} {{#truncate}}{{description}}{{/truncate}} </ li > {{/products}} </ ul > Or the pseudo-equivalent Cottle script: < ul id = 'products' > { for product in products: < li > < h2 > { product.Name } </ h2 > Only { product.Price } { string.truncate(product.Description, 15) } </ li > } </ ul > The raw results of the benchmarks are: // * Summary * BenchmarkDotNet=v0.11.4, OS=Windows 10.0.17134.590 (1803/April2018Update/Redstone4) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 | Method | Mean | Error | StdDev | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op | |-------------------------- |-------------:|------------:|------------:|------------:|------------:|------------:|--------------------:| | 'Scriban - Parser' | 10.20 us | 0.0327 us | 0.0306 us | 1.0376 | - | - | 4.29 KB | | 'DotLiquid - Parser' | 66.33 us | 0.3275 us | 0.2903 us | 3.7842 | - | - | 15.55 KB | | 'Stubble - Parser' | 14.21 us | 0.0864 us | 0.0721 us | 2.7618 | - | - | 11.37 KB | | 'Nustache - Parser' | 46.97 us | 0.4216 us | 0.3291 us | 6.5308 | - | - | 26.87 KB | | 'Handlebars.NET - Parser' | 1,645.16 us | 9.5167 us | 8.4363 us | 60.5469 | 1.9531 | - | 254.46 KB | | 'Cottle - Parser' | 11.20 us | 0.1197 us | 0.1000 us | 2.8229 | - | - | 11.57 KB | | 'Fluid - Parser' | 27.74 us | 0.5366 us | 0.7164 us | 7.0190 | - | - | 28.94 KB | | 'Razor - Parser' | 13,338.41 us | 264.8221 us | 644.6136 us | - | - | - | 3725.36 KB | About the results, we couldn't include Handlebars.NET in the following chart, as it is compiling to IL so it takes a lot more time to compile a template.","title":"Parser Benchmarks"},{"location":"benchmarks/#rendering-benchmarks","text":"The methodology is to use the previously compiled script and use it with a list of 500 Products to output a final string BenchmarkDotNet=v0.11.4, OS=Windows 10.0.17134.590 (1803/April2018Update/Redstone4) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 Method Mean Error StdDev Gen 0/1k Op Gen 1/1k Op Gen 2/1k Op Allocated Memory/Op Scriban 992.7 us 4.068 us 3.805 us 44.9219 17.5781 17.5781 213.04 KB ScribanAsync 4,268.2 us 18.446 us 16.352 us 23.4375 - - 212.93 KB DotLiquid 7,775.8 us 22.148 us 18.494 us 953.1250 93.7500 - 4050.74 KB Stubble 5,014.9 us 19.147 us 17.910 us 656.2500 - - 2796.59 KB Nustache 22,360.3 us 216.415 us 202.435 us 5562.5000 - - 22964.2 KB Handlebars 3,060.3 us 24.703 us 23.107 us 277.3438 31.2500 11.7188 1188.8 KB Cottle 2,039.5 us 11.350 us 10.617 us 218.7500 109.3750 11.7188 1329.83 KB Fluid 913.5 us 2.231 us 1.977 us 56.6406 20.5078 19.5313 245.3 KB Razor 314.3 us 3.107 us 2.595 us 58.1055 29.2969 19.0430 253.57 KB Note that for Stubble, It was not possible to match the behavior of the other engines, so it is including the parsing time (which is anyway insignificant compare to the rendering time in this particular case)","title":"Rendering Benchmarks"},{"location":"builtins/","text":"Builtins This document describes the various built-in functions available in scriban. array functions date functions html functions math functions object functions regex functions string functions timespan functions :top: array functions Array functions available through the object 'array' in scriban. array.add array.add_range array.compact array.concat array.cycle array.each array.filter array.first array.insert_at array.join array.last array.limit array.map array.offset array.remove_at array.reverse array.size array.sort array.uniq array.contains array.add array.add <list> <value> Description Adds a value to the input list. Arguments list : The input list value : The value to add at the end of the list Returns A new list with the value added Examples input {{ [1, 2, 3] | array.add 4 }} output [1, 2, 3, 4] array.add_range array.add_range <list1> <list2> Description Concatenates two lists. Arguments list1 : The 1st input list list2 : The 2nd input list Returns The concatenation of the two input lists Examples input {{ [1, 2, 3] | array.add_range [4, 5] }} output [1, 2, 3, 4, 5] array.compact array.compact <list> Description Removes any non-null values from the input list. Arguments list : An input list Returns Returns a list with null value removed Examples input {{ [1, null, 3] | array.compact }} output [1, 3] array.concat array.concat <list1> <list2> Description Concatenates two lists. Arguments list1 : The 1st input list list2 : The 2nd input list Returns The concatenation of the two input lists Examples input {{ [1, 2, 3] | array.concat [4, 5] }} output [1, 2, 3, 4, 5] array.cycle array.cycle <list> <group>? Description Loops through a group of strings and outputs them in the order that they were passed as parameters. Each time cycle is called, the next string that was passed as a parameter is output. Arguments list : An input list group : The group used. Default is null Returns Returns a list with null value removed Examples input {{ array.cycle ['one', 'two', 'three'] }} {{ array.cycle ['one', 'two', 'three'] }} {{ array.cycle ['one', 'two', 'three'] }} {{ array.cycle ['one', 'two', 'three'] }} output one two three one cycle accepts a parameter called cycle group in cases where you need multiple cycle blocks in one template. If no name is supplied for the cycle group, then it is assumed that multiple calls with the same parameters are one group. array.each array.each <list> <function> Description Applies the specified function to each element of the input. Arguments list : An input list function : The function to apply to each item in the list Returns Returns a list with each item being transformed by the function. Examples input {{ [\" a\", \" 5\", \"6 \"] | array.each @string.strip }} output [\"a\", \"5\", \"6\"] array.filter array.filter <list> <function> Description Filters the input list according the supplied filter function. Arguments list : An input list function : The function used to test each elemement of the list Returns Returns a new list which contains only those elements which match the filter function. Examples input {{[\"\", \"200\", \"\",\"400\"] | array.filter @string.empty}} output [\"\", \"\"] array.first array.first <list> Description Returns the first element of the input list . Arguments list : The input list Returns The first element of the input list . Examples input {{ [4, 5, 6] | array.first }} output 4 array.insert_at array.insert_at <list> <index> <value> Description Inserts a value at the specified index in the input list . Arguments list : The input list index : The index in the list where to insert the element value : The value to insert Returns A new list with the element inserted. Examples input {{ [\"a\", \"b\", \"c\"] | array.insert_at 2 \"Yo\" }} output [\"a\", \"b\", \"Yo\", \"c\"] array.join array.join <list> <delimiter> <function>? Description Joins the element of a list separated by a delimiter string and return the concatenated string. Arguments list : The input list delimiter : The delimiter string to use to separate elements in the output string function : An optional function that will receive the string representation of the item to join and can transform the text before joining. Returns A new list with the element inserted. Examples input {{ [1, 2, 3] | array.join \"|\" }} output 1|2|3 array.last array.last <list> Description Returns the last element of the input list . Arguments list : The input list Returns The last element of the input list . Examples input {{ [4, 5, 6] | array.last }} output 6 array.limit array.limit <list> <count> Description Returns a limited number of elments from the input list Arguments list : The input list count : The number of elements to return from the input list Returns Examples input {{ [4, 5, 6] | array.limit 2 }} output [4, 5] array.map array.map <list> <member> Description Accepts an array element's attribute as a parameter and creates an array out of each array element's value. Arguments list : The input list member : The member to extract the value from Returns Examples input {{ products = [{title: \"orange\", type: \"fruit\"}, {title: \"computer\", type: \"electronics\"}, {title: \"sofa\", type: \"furniture\"}] products | array.map \"type\" | array.uniq | array.sort }} output [\"electronics\", \"fruit\", \"furniture\"] array.offset array.offset <list> <index> Description Returns the remaining of the list after the specified offset Arguments list : The input list index : The index of a list to return elements Returns Examples input {{ [4, 5, 6, 7, 8] | array.offset 2 }} output [6, 7, 8] array.remove_at array.remove_at <list> <index> Description Removes an element at the specified index from the input list Arguments list : The input list index : The index of a list to return elements Returns A new list with the element removed. If index is negative, remove at the end of the list. Examples input {{ [4, 5, 6, 7, 8] | array.remove_at 2 }} output [4, 5, 7, 8] If the index is negative, removes at the end of the list (notice that we need to put -1 in parenthesis to avoid confusing the parser with a binary - operation): input {{ [4, 5, 6, 7, 8] | array.remove_at (-1) }} output [4, 5, 6, 7] array.reverse array.reverse <list> Description Reverses the input list Arguments list : The input list Returns A new list in reversed order. Examples input {{ [4, 5, 6, 7] | array.reverse }} output [7, 6, 5, 4] array.size array.size <list> Description Returns the number of elements in the input list Arguments list : The input list Returns A number of elements in the input list . Examples input {{ [4, 5, 6] | array.size }} output 3 array.sort array.sort <list> <member>? Description Sorts the elements of the input list according to the value of each element or the value of the specified member of each element Arguments list : The input list member : The member name to sort according to its value. Null by default, meaning that the element's value are used instead. Returns A list sorted according to the value of each element or the value of the specified member of each element. Examples Sorts by element's value: input {{ [10, 2, 6] | array.sort }} output [2, 6, 10] Sorts by elements member's value: input {{ products = [{title: \"orange\", type: \"fruit\"}, {title: \"computer\", type: \"electronics\"}, {title: \"sofa\", type: \"furniture\"}] products | array.sort \"title\" | array.map \"title\" }} output [\"computer\", \"orange\", \"sofa\"] array.uniq array.uniq <list> Description Returns the unique elements of the input list . Arguments list : The input list Returns A list of unique elements of the input list . Examples input {{ [1, 1, 4, 5, 8, 8] | array.uniq }} output [1, 4, 5, 8] array.contains array.contains <list> <item> Description Returns if an list contains an specifique element Arguments list : the input list item : the input item Returns true if element is in list ; otherwise false Examples input {{ [1, 2, 3, 4] | array.contains 4 }} output true date functions A datetime object represents an instant in time, expressed as a date and time of day. Name Description .year Gets the year of a date object .month Gets the month of a date object .day Gets the day in the month of a date object .day_of_year Gets the day within the year .hour Gets the hour of the date object .minute Gets the minute of the date object .second Gets the second of the date object .millisecond Gets the millisecond of the date object Binary operations The substract operation date1 - date2 : Substract date2 from date1 and return a timespan internal object (see timespan object below). Other comparison operators( == , != , <= , >= , < , > ) are also working with date objects. A timespan and also the added to a datetime object. date.now date.add_days date.add_months date.add_years date.add_hours date.add_minutes date.add_seconds date.add_milliseconds date.parse date.to_string date.now date.now Description Returns a datetime object of the current time, including the hour, minutes, seconds and milliseconds. Arguments Returns Examples input {{ date.now.year }} output 2021 date.add_days date.add_days <date> <days> Description Adds the specified number of days to the input date. Arguments date : The date. days : The days. Returns A new date Examples input {{ date.parse '2016/01/05' | date.add_days 1 }} output 06 Jan 2016 date.add_months date.add_months <date> <months> Description Adds the specified number of months to the input date. Arguments date : The date. months : The months. Returns A new date Examples input {{ date.parse '2016/01/05' | date.add_months 1 }} output 05 Feb 2016 date.add_years date.add_years <date> <years> Description Adds the specified number of years to the input date. Arguments date : The date. years : The years. Returns A new date Examples input {{ date.parse '2016/01/05' | date.add_years 1 }} output 05 Jan 2017 date.add_hours date.add_hours <date> <hours> Description Adds the specified number of hours to the input date. Arguments date : The date. hours : The hours. Returns A new date Examples date.add_minutes date.add_minutes <date> <minutes> Description Adds the specified number of minutes to the input date. Arguments date : The date. minutes : The minutes. Returns A new date Examples date.add_seconds date.add_seconds <date> <seconds> Description Adds the specified number of seconds to the input date. Arguments date : The date. seconds : The seconds. Returns A new date Examples date.add_milliseconds date.add_milliseconds <date> <millis> Description Adds the specified number of milliseconds to the input date. Arguments date : The date. millis : The milliseconds. Returns A new date Examples date.parse date.parse <text> Description Parses the specified input string to a date object. Arguments text : A text representing a date. Returns A date object Examples input {{ date.parse '2016/01/05' }} output 05 Jan 2016 date.to_string date.to_string <datetime> <pattern> <culture> Description Converts a datetime object to a textual representation using the specified format string. By default, if you are using a date, it will use the format specified by date.format which defaults to date.default_format (readonly) which default to %d %b %Y You can override the format used for formatting all dates by assigning the a new format: date.format = '%a %b %e %T %Y'; You can recover the default format by using date.format = date.default_format; By default, the to_string format is using the current culture , but you can switch to an invariant culture by using the modifier %g For example, using %g %d %b %Y will output the date using an invariant culture. If you are using %g alone, it will output the date with date.format using an invariant culture. Suppose that date.now would return the date 2013-09-12 22:49:27 +0530 , the following table explains the format modifiers: Format Result Description \"%a\" \"Thu\" Name of week day in short form of the \"%A\" \"Thursday\" Week day in full form of the time \"%b\" \"Sep\" Month in short form of the time \"%B\" \"September\" Month in full form of the time \"%c\" Date and time (%a %b %e %T %Y) \"%C\" \"20\" Century of the time \"%d\" \"12\" Day of the month of the time \"%D\" \"09/12/13\" Date (%m/%d/%y) \"%e\" \"12\" Day of the month, blank-padded ( 1..31) \"%F\" \"2013-09-12\" ISO 8601 date (%Y-%m-%d) \"%h\" \"Sep\" Alias for %b \"%H\" \"22\" Hour of the time in 24 hour clock format \"%I\" \"10\" Hour of the time in 12 hour clock format \"%j\" \"255\" Day of the year (001..366) (3 digits, left padded with zero) \"%k\" \"22\" Hour of the time in 24 hour clock format, blank-padded ( 0..23) \"%l\" \"10\" Hour of the time in 12 hour clock format, blank-padded ( 0..12) \"%L\" \"000\" Millisecond of the time (3 digits, left padded with zero) \"%m\" \"09\" Month of the time \"%M\" \"49\" Minutes of the time (2 digits, left padded with zero e.g 01 02) \"%n\" Newline character (\\n) \"%N\" \"000000000\" Nanoseconds of the time (9 digits, left padded with zero) \"%p\" \"PM\" Gives AM / PM of the time \"%P\" \"pm\" Gives am / pm of the time \"%r\" \"10:49:27 PM\" Long time in 12 hour clock format (%I:%M:%S %p) \"%R\" \"22:49\" Short time in 24 hour clock format (%H:%M) \"%s\" Number of seconds since 1970-01-01 00:00:00 +0000 \"%S\" \"27\" Seconds of the time \"%t\" Tab character (\\t) \"%T\" \"22:49:27\" Long time in 24 hour clock format (%H:%M:%S) \"%u\" \"4\" Day of week of the time (from 1 for Monday to 7 for Sunday) \"%U\" \"36\" Week number of the current year, starting with the first Sunday as the first day of the first week (00..53) \"%v\" \"12-SEP-2013\" VMS date (%e-%b-%Y) (culture invariant) \"%V\" \"37\" Week number of the current year according to ISO 8601 (01..53) \"%W\" \"36\" Week number of the current year, starting with the first Monday as the first day of the first week (00..53) \"%w\" \"4\" Day of week of the time (from 0 for Sunday to 6 for Saturday) \"%x\" Preferred representation for the date alone, no time \"%X\" Preferred representation for the time alone, no date \"%y\" \"13\" Gives year without century of the time \"%Y\" \"2013\" Year of the time \"%Z\" \"IST\" Gives Time Zone of the time \"%%\" \"%\" Output the character % Note that the format is using a good part of the ruby format ( source ) Examples input {{ date.parse '2016/01/05' | date.to_string '%d %b %Y' }} {{ date.parse '2016/01/05' | date.to_string '%d %B %Y' 'fr-FR' }} output 05 Jan 2016 05 janvier 2016 Arguments datetime : The input datetime to format pattern : The date format pattern. culture : The culture used to format the datetime Returns A that represents this instance. html functions Html functions available through the builtin object 'html'. html.strip html.escape html.url_encode html.url_escape html.strip html.strip <text> Description Removes any HTML tags from the input string Arguments text : The input string Returns The input string removed with any HTML tags Examples input {{ \"<p>This is a paragraph</p>\" | html.strip }} output This is a paragraph html.escape html.escape <text> Description Escapes a HTML input string (replacing & by &amp; ) Arguments text : The input string Returns The input string removed with any HTML tags Examples input {{ \"<p>This is a paragraph</p>\" | html.escape }} output &lt; p &gt; This is a paragraph &lt; /p &gt; html.url_encode html.url_encode <text> Description Converts any URL-unsafe characters in a string into percent-encoded characters. Arguments text : The input string Returns The input string url encoded Examples input {{ \"john@liquid.com\" | html.url_encode }} output john%40liquid.com html.url_escape html.url_escape <text> Description Identifies all characters in a string that are not allowed in URLS, and replaces the characters with their escaped variants. Arguments text : The input string Returns The input string url escaped Examples input {{ \"<hello> & <scriban>\" | html.url_escape }} output %3Chello%3E%20 & %20%3Cscriban%3E math functions Math functions available through the object 'math' in scriban. math.abs math.ceil math.divided_by math.floor math.format math.is_number math.minus math.modulo math.plus math.round math.times math.uuid math.random math.abs math.abs <value> Description Returns the absolute value of a specified number. Arguments value : The input value Returns The absolute value of the input value Examples input {{ -15.5| math.abs }} {{ -5| math.abs }} output 15.5 5 math.ceil math.ceil <value> Description Returns the smallest integer greater than or equal to the specified number. Arguments value : The input value Returns The smallest integer greater than or equal to the specified number. Examples input {{ 4.6 | math.ceil }} {{ 4.3 | math.ceil }} output 5 5 math.divided_by math.divided_by <value> <divisor> Description Divides the specified value by another value. If the divisor is an integer, the result will be floor to and converted back to an integer. Arguments value : The input value divisor : The divisor value Returns The division of value by divisor . Examples input {{ 8.4 | math.divided_by 2.0 | math.round 1 }} {{ 8.4 | math.divided_by 2 }} output 4.2 4 math.floor math.floor <value> Description Returns the largest integer less than or equal to the specified number. Arguments value : The input value Returns The largest integer less than or equal to the specified number. Examples input {{ 4.6 | math.floor }} {{ 4.3 | math.floor }} output 4 4 math.format math.format <value> <format> <culture>? Description Formats a number value with specified .NET standard numeric format strings Arguments value : The input value format : The format string. culture : The culture as a string (e.g en-US ). By default the culture from is used Returns The largest integer less than or equal to the specified number. Examples input {{ 255 | math.format \"X4\" }} output 00FF math.is_number math.is_number <value> Description Returns a boolean indicating if the input value is a number Arguments value : The input value Returns true if the input value is a number; otherwise false. Examples input {{ 255 | math.is_number }} {{ \"yo\" | math.is_number }} output true false math.minus math.minus <value> <with> Description Substracts from the input value the with value Arguments value : The input value with : The with value to substract from value Returns The results of the substraction: value - with Examples input {{ 255 | math.minus 5 }} output 250 math.modulo math.modulo <value> <with> Description Performs the modulo of the input value with the with value Arguments value : The input value with : The with value to module value Returns The results of the modulo: value % with Examples input {{ 11 | math.modulo 10 }} output 1 math.plus math.plus <value> <with> Description Performs the addition of the input value with the with value Arguments value : The input value with : The with value to add to value Returns The results of the addition: value + with Examples input {{ 1 | math.plus 2 }} output 3 math.round math.round <value> <precision: 0>? Description Rounds a value to the nearest integer or to the specified number of fractional digits. Arguments value : The input value precision : The number of fractional digits in the return value. Default is 0. Returns A value rounded to the nearest integer or to the specified number of fractional digits. Examples input {{ 4.6 | math.round }} {{ 4.3 | math.round }} {{ 4.5612 | math.round 2 }} output 5 4 4.56 math.times math.times <value> <with> Description Performs the multiplication of the input value with the with value Arguments value : The input value with : The with value to multiply to value Returns The results of the multiplication: value * with Examples input {{ 2 | math.times 3}} output 6 math.uuid math.uuid Description Creates a new UUID Arguments Returns The created UUID, ex. 2dc55d50-3f6c-446a-87d0-a5a4eed23269 Examples input {{ math . uuid }} output 1c0a4aa8-680e-4bd6-95e9-cdbec45ef057 math.random math.random <minValue> <maxValue> Description Creates a random number Arguments minValue : The inclusive lower bound of the random number returned maxValue : The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue. Returns A random number greater or equal to minValue and less than maxValue Examples input {{ math.random 1 10 }} output 7 object functions Object functions available through the builtin object 'object'. object.default object.eval object.eval_template object.format object.has_key object.has_value object.keys object.size object.typeof object.kind object.values :top: object.default object.default <value> <default> Description The default value is returned if the input value is null or an empty string \"\". A string containing whitespace characters will not resolve to the default value. Arguments value : The input value to check if it is null or an empty string. default : The default value to return if the input value is null or an empty string. Returns The default value is returned if the input value is null or an empty string \"\", otherwise it returns value Examples input {{ undefined_var | object.default \"Yo\" }} output Yo :top: object.eval object.eval <value> Description The evaluates a string as a scriban expression or evaluate the passed function or return the passed value. Arguments value : The input value, either a scriban template in a string, or an alias function or directly a value. Returns The evaluation of the input value. Examples input {{ \"1 + 2\" | object.eval }} output 3 :top: object.eval_template object.eval_template <value> Description The evaluates a string as a scriban template or evaluate the passed function or return the passed value. Arguments value : The input value, either a scriban template in a string, or an alias function or directly a value. Returns The evaluation of the input value. Examples input {{ \"This is a template text {{ 1 + 2 }}\" | object.eval_template }} output This is a template text 3 :top: object.format object.format <value> <format> <culture>? Description Formats an object using specified format. Arguments value : The input value format : The format string. culture : The culture as a string (e.g en-US ). By default the culture from is used Returns Examples input {{ 255 | object.format \"X4\" }} {{ 1523 | object.format \"N2\" \"fr-FR\" }} output 00FF 1 523,00 :top: object.has_key object.has_key <value> <key> Description Checks if the specified object as the member key Arguments value : The input object. key : The member name to check its existence. Returns true if the input object contains the member key ; otherwise false Examples input {{ product | object.has_key \"title\" }} output true :top: object.has_value object.has_value <value> <key> Description Checks if the specified object as a value for the member key Arguments value : The input object. key : The member name to check the existence of its value. Returns true if the input object contains the member key and has a value; otherwise false Examples input {{ product | object.has_value \"title\" }} output true :top: object.keys object.keys <value> Description Gets the members/keys of the specified value object. Arguments value : The input object. Returns A list with the member names/key of the input object Examples input {{ product | object.keys | array.sort }} output [\"title\", \"type\"] :top: object.size object.size <value> Description Returns the size of the input object. - If the input object is a string, it will return the length - If the input is a list, it will return the number of elements - If the input is an object, it will return the number of members Arguments value : The input object. Returns The size of the input object. Examples input {{ [1, 2, 3] | object.size }} output 3 :top: object.typeof object.typeof <value> Description Returns string representing the type of the input object. The type can be string , boolean , number , array , iterator and object Arguments value : The input object. Returns Examples input {{ null | object.typeof }} {{ true | object.typeof }} {{ 1 | object.typeof }} {{ 1.0 | object.typeof }} {{ \"text\" | object.typeof }} {{ 1..5 | object.typeof }} {{ [1,2,3,4,5] | object.typeof }} {{ {} | object.typeof }} {{ object | object.typeof }} output boolean number number string iterator array object object :top: object.kind object.kind <value> Description Returns string representing the type of the input object. The type can be string , bool , number , array , iterator and object Arguments value : The input object. Returns Examples This function is newer than object.typeof and returns more detailed results about the types (e.g instead of number , returns int or double ) input {{ null | object.kind }} {{ true | object.kind }} {{ 1 | object.kind }} {{ 1.0 | object.kind }} {{ \"text\" | object.kind }} {{ 1..5 | object.kind }} {{ [1,2,3,4,5] | object.kind }} {{ {} | object.kind }} {{ object | object.kind }} output bool int double string range array object object :top: object.values object.values <value> Description Gets the member's values of the specified value object. Arguments value : The input object. Returns A list with the member values of the input object Examples input {{ product | object.values | array.sort }} output [\"fruit\", \"Orange\"] :top: regex functions Functions exposed through regex builtin object. regex.escape regex.match regex.matches regex.replace regex.split regex.unescape :top: regex.escape regex.escape <pattern> Description Escapes a minimal set of characters ( \\ , * , + , ? , | , { , [ , ( , ) , ^ , $ , . , # , and white space) by replacing them with their escape codes. This instructs the regular expression engine to interpret these characters literally rather than as metacharacters. Arguments pattern : The input string that contains the text to convert. Returns A string of characters with metacharacters converted to their escaped form. Examples input {{ \"(abc.*)\" | regex.escape }} output \\(abc\\.\\*\\) :top: regex.match regex.match <text> <pattern> <options>? Description Searches an input string for a substring that matches a regular expression pattern and returns an array with the match occurences. Arguments text : The string to search for a match. pattern : The regular expression pattern to match. options : A string with regex options, that can contain the following option characters (default is null ): - i : Specifies case-insensitive matching. - m : Multiline mode. Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string. - s : Specifies single-line mode. Changes the meaning of the dot . so it matches every character (instead of every character except \\n ). - x : Eliminates unescaped white space from the pattern and enables comments marked with # . Returns An array that contains all the match groups. The first group contains the entire match. The other elements contain regex matched groups (..) . An empty array returned means no match. Examples input {{ \"this is a text123\" | regex.match `(\\w+) a ([a-z]+\\d+)` }} output [\"is a text123\", \"is\", \"text123\"] Notice that the first element returned in the array is the entire regex match, followed by the regex group matches. :top: regex.matches regex.matches <text> <pattern> <options>? Description Searches an input string for multiple substrings that matches a regular expression pattern and returns an array with the match occurences. Arguments text : The string to search for a match. pattern : The regular expression pattern to match. options : A string with regex options, that can contain the following option characters (default is null ): - i : Specifies case-insensitive matching. - m : Multiline mode. Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string. - s : Specifies single-line mode. Changes the meaning of the dot . so it matches every character (instead of every character except \\n ). - x : Eliminates unescaped white space from the pattern and enables comments marked with # . Returns An array of matches that contains all the match groups. The first group contains the entire match. The other elements contain regex matched groups (..) . An empty array returned means no match. Examples input {{ \"this is a text123\" | regex.matches `(\\w+)` }} output [[\"this\", \"this\"], [\"is\", \"is\"], [\"a\", \"a\"], [\"text123\", \"text123\"]] Notice that the first element returned in the sub array is the entire regex match, followed by the regex group matches. :top: regex.replace regex.replace <text> <pattern> <replace> <options>? Description In a specified input string, replaces strings that match a regular expression pattern with a specified replacement string. Arguments text : The string to search for a match. pattern : The regular expression pattern to match. replace : The replacement string. options : A string with regex options, that can contain the following option characters (default is null ): - i : Specifies case-insensitive matching. - m : Multiline mode. Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string. - s : Specifies single-line mode. Changes the meaning of the dot . so it matches every character (instead of every character except \\n ). - x : Eliminates unescaped white space from the pattern and enables comments marked with # . Returns A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If pattern is not matched in the current instance, the method returns the current instance unchanged. Examples input {{ \"abbbbcccd\" | regex.replace \"b+c+\" \"-Yo-\" }} output a-Yo-d :top: regex.split regex.split <text> <pattern> <options>? Description Splits an input string into an array of substrings at the positions defined by a regular expression match. Arguments text : The string to split. pattern : The regular expression pattern to match. options : A string with regex options, that can contain the following option characters (default is null ): - i : Specifies case-insensitive matching. - m : Multiline mode. Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string. - s : Specifies single-line mode. Changes the meaning of the dot . so it matches every character (instead of every character except \\n ). - x : Eliminates unescaped white space from the pattern and enables comments marked with # . Returns A string array. Examples input {{ \"a, b , c, d\" | regex.split `\\s*,\\s*` }} output [\"a\", \"b\", \"c\", \"d\"] :top: regex.unescape regex.unescape <pattern> Description Converts any escaped characters in the input string. Arguments pattern : The input string containing the text to convert. Returns A string of characters with any escaped characters converted to their unescaped form. Examples input {{ \"\\\\(abc\\\\.\\\\*\\\\)\" | regex.unescape }} output (abc.*) :top: string functions String functions available through the builtin object 'string`. string.escape string.append string.capitalize string.capitalizewords string.contains string.empty string.whitespace string.downcase string.ends_with string.handleize string.literal string.lstrip string.pluralize string.prepend string.remove string.remove_first string.replace string.replace_first string.rstrip string.size string.slice string.slice1 string.split string.starts_with string.strip string.strip_newlines string.to_int string.to_long string.to_float string.to_double string.truncate string.truncatewords string.upcase string.md5 string.sha1 string.sha256 string.hmac_sha1 string.hmac_sha256 string.pad_left string.pad_right string.base64_encode string.base64_decode :top: string.escape string.escape <text> Description Escapes a string with escape characters. Arguments text : The input string Returns The two strings concatenated Examples input {{ \"Hel\\tlo\\n\\\"W\\\\orld\" | string.escape }} output Hel\\tlo\\n\\\"W\\\\orld :top: string.append string.append <text> <with> Description Concatenates two strings Arguments text : The input string with : The text to append Returns The two strings concatenated Examples input {{ \"Hello\" | string.append \" World\" }} output Hello World :top: string.capitalize string.capitalize <text> Description Converts the first character of the passed string to a upper case character. Arguments text : The input string Returns The capitalized input string Examples input {{ \"test\" | string.capitalize }} output Test :top: string.capitalizewords string.capitalizewords <text> Description Converts the first character of each word in the passed string to a upper case character. Arguments text : The input string Returns The capitalized input string Examples input {{ \"This is easy\" | string.capitalizewords }} output This Is Easy :top: string.contains string.contains <text> <value> Description Returns a boolean indicating whether the input string contains the specified string value . Arguments text : The input string value : The string to look for Returns if text contains the string value Examples input {{ \"This is easy\" | string.contains \"easy\" }} output true :top: string.empty string.empty <text> Description Returns a boolean indicating whether the input string is an empty string. Arguments text : The input string Returns if text is an empty string Examples input {{ \"\" | string.empty }} output true :top: string.whitespace string.whitespace <text> Description Returns a boolean indicating whether the input string is empty or contains only whitespace characters. Arguments text : The input string Returns if text is empty string or contains only whitespace characters Examples input {{ \"\" | string.whitespace }} output true :top: string.downcase string.downcase <text> Description Converts the string to lower case. Arguments text : The input string Returns The input string lower case Examples input {{ \"TeSt\" | string.downcase }} output test :top: string.ends_with string.ends_with <text> <value> Description Returns a boolean indicating whether the input string ends with the specified string value . Arguments text : The input string value : The string to look for Returns if text ends with the specified string value Examples input {{ \"This is easy\" | string.ends_with \"easy\" }} output true :top: string.handleize string.handleize <text> Description Returns a url handle from the input string. Arguments text : The input string Returns A url handle Examples input {{ '100% M & Ms!!!' | string.handleize }} output 100-m-ms :top: string.literal string.literal <text> Description Return a string literal enclosed with double quotes of the input string. Arguments text : The string to return a literal from. Returns The literal of a string. Examples If the input string has non printable characters or they need contain a double quote, they will be escaped. input {{ 'Hello\\n\"World\"' | string.literal }} output \"Hello\\n\\\"World\\\"\" :top: string.lstrip string.lstrip <text> Description Removes any whitespace characters on the left side of the input string. Arguments text : The input string Returns The input string without any left whitespace characters Examples input {{ ' too many spaces' | string.lstrip }} Highlight to see the empty spaces to the right of the string output too many spaces :top: string.pluralize string.pluralize <number> <singular> <plural> Description Outputs the singular or plural version of a string based on the value of a number. Arguments number : The number to check singular : The singular string to return if number is == 1 plural : The plural string to return if number is != 1 Returns The singular or plural string based on number Examples input {{ products.size }} {{products.size | string.pluralize 'product' 'products' }} output 7 products :top: string.prepend string.prepend <text> <by> Description Concatenates two strings by placing the by string in from of the text string Arguments text : The input string by : The string to prepend to text Returns The two strings concatenated Examples input {{ \"World\" | string.prepend \"Hello \" }} output Hello World :top: string.remove string.remove <text> <remove> Description Removes all occurrences of a substring from a string. Arguments text : The input string remove : The substring to remove from the text string Returns The input string with the all occurence of a substring removed Examples input {{ \"Hello, world. Goodbye, world.\" | string.remove \"world\" }} output Hello, . Goodbye, . :top: string.remove_first string.remove_first <text> <remove> Description Removes the first occurrence of a substring from a string. Arguments text : The input string remove : The first occurence of substring to remove from the text string Returns The input string with the first occurence of a substring removed Examples input {{ \"Hello, world. Goodbye, world.\" | string.remove_first \"world\" }} output Hello, . Goodbye, world. :top: string.replace string.replace <text> <match> <replace> Description Replaces all occurrences of a string with a substring. Arguments text : The input string match : The substring to find in the text string replace : The substring used to replace the string matched by match in the input text Returns The input string replaced Examples input {{ \"Hello, world. Goodbye, world.\" | string.replace \"world\" \"buddy\" }} output Hello, buddy. Goodbye, buddy. :top: string.replace_first string.replace_first <text> <match> <replace> Description Replaces the first occurrence of a string with a substring. Arguments text : The input string match : The substring to find in the text string replace : The substring used to replace the string matched by match in the input text Returns The input string replaced Examples input {{ \"Hello, world. Goodbye, world.\" | string.replace_first \"world\" \"buddy\" }} output Hello, buddy. Goodbye, world. :top: string.rstrip string.rstrip <text> Description Removes any whitespace characters on the right side of the input string. Arguments text : The input string Returns The input string without any left whitespace characters Examples input {{ ' too many spaces ' | string.rstrip }} Highlight to see the empty spaces to the right of the string output too many spaces :top: string.size string.size <text> Description Returns the number of characters from the input string Arguments text : The input string Returns The length of the input string Examples input {{ \"test\" | string.size }} output 4 :top: string.slice string.slice <text> <start> <length>? Description The slice returns a substring, starting at the specified index. An optional second parameter can be passed to specify the length of the substring. If no second parameter is given, a substring with the remaining characters will be returned. Arguments text : The input string start : The starting index character where the slice should start from the input text string length : The number of character. Default is 0, meaning that the remaining of the string will be returned. Returns The input string sliced Examples input {{ \"hello\" | string.slice 0 }} {{ \"hello\" | string.slice 1 }} {{ \"hello\" | string.slice 1 3 }} {{ \"hello\" | string.slice 1 length:3 }} output hello ello ell ell :top: string.slice1 string.slice1 <text> <start> <length: 1>? Description The slice returns a substring, starting at the specified index. An optional second parameter can be passed to specify the length of the substring. If no second parameter is given, a substring with the first character will be returned. Arguments text : The input string start : The starting index character where the slice should start from the input text string length : The number of character. Default is 1, meaning that only the first character at start position will be returned. Returns The input string sliced Examples input {{ \"hello\" | string.slice1 0 }} {{ \"hello\" | string.slice1 1 }} {{ \"hello\" | string.slice1 1 3 }} {{ \"hello\" | string.slice1 1 length: 3 }} output h e ell ell :top: string.split string.split <text> <match> Description The split function takes on a substring as a parameter. The substring is used as a delimiter to divide a string into an array. You can output different parts of an array using array functions. Arguments text : The input string match : The string used to split the input text string Returns An enumeration of the substrings Examples input {{ for word in \"Hi, how are you today?\" | string.split ' ' ~}} {{ word }} {{ end ~}} output Hi, how are you today? :top: string.starts_with string.starts_with <text> <value> Description Returns a boolean indicating whether the input string starts with the specified string value . Arguments text : The input string value : The string to look for Returns if text starts with the specified string value Examples input {{ \"This is easy\" | string.starts_with \"This\" }} output true :top: string.strip string.strip <text> Description Removes any whitespace characters on the left and right side of the input string. Arguments text : The input string Returns The input string without any left and right whitespace characters Examples input {{ ' too many spaces ' | string.strip }} Highlight to see the empty spaces to the right of the string output too many spaces :top: string.strip_newlines string.strip_newlines <text> Description Removes any line breaks/newlines from a string. Arguments text : The input string Returns The input string without any breaks/newlines characters Examples input {{ \"This is a string.\\r\\n With \\nanother \\rstring\" | string.strip_newlines }} output This is a string. With another string :top: string.to_int string.to_int <text> Description Converts a string to an integer Arguments text : The input string Returns A 32 bit integer or null if conversion failed Examples input {{ \"123\" | string.to_int + 1 }} output 124 :top: string.to_long string.to_long <text> Description Converts a string to a long 64 bit integer Arguments text : The input string Returns A 64 bit integer or null if conversion failed Examples input {{ \"123678912345678\" | string.to_long + 1 }} output 123678912345679 :top: string.to_float string.to_float <text> Description Converts a string to a float Arguments text : The input string Returns A 32 bit float or null if conversion failed Examples input {{ \"123.4\" | string.to_float + 1 }} output 124.4 :top: string.to_double string.to_double <text> Description Converts a string to a double Arguments text : The input string Returns A 64 bit float or null if conversion failed Examples input {{ \"123.4\" | string.to_double + 1 }} output 124.4 :top: string.truncate string.truncate <text> <length> <ellipsis>? Description Truncates a string down to the number of characters passed as the first parameter. An ellipsis (...) is appended to the truncated string and is included in the character count Arguments text : The input string length : The maximum length of the output string, including the length of the ellipsis ellipsis : The ellipsis to append to the end of the truncated string Returns The truncated input string Examples input {{ \"The cat came back the very next day\" | string.truncate 13 }} output The cat ca... :top: string.truncatewords string.truncatewords <text> <count> <ellipsis>? Description Truncates a string down to the number of words passed as the first parameter. An ellipsis (...) is appended to the truncated string. Arguments text : The input string count : The number of words to keep from the input text string before appending the ellipsis ellipsis : The ellipsis to append to the end of the truncated string Returns The truncated input string Examples input {{ \"The cat came back the very next day\" | string.truncatewords 4 }} output The cat came back... :top: string.upcase string.upcase <text> Description Converts the string to uppercase Arguments text : The input string Returns The input string upper case Examples input {{ \"test\" | string.upcase }} output TEST :top: string.md5 string.md5 <text> Description Computes the md5 hash of the input string Arguments text : The input string Returns The md5 hash of the input string Examples input {{ \"test\" | string.md5 }} output 098f6bcd4621d373cade4e832627b4f6 :top: string.sha1 string.sha1 <text> Description Computes the sha1 hash of the input string Arguments text : The input string Returns The sha1 hash of the input string Examples input {{ \"test\" | string.sha1 }} output a94a8fe5ccb19ba61c4c0873d391e987982fbbd3 :top: string.sha256 string.sha256 <text> Description Computes the sha256 hash of the input string Arguments text : The input string Returns The sha256 hash of the input string Examples input {{ \"test\" | string.sha256 }} output 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 :top: string.hmac_sha1 string.hmac_sha1 <text> <secretKey> Description Converts a string into a SHA-1 hash using a hash message authentication code (HMAC). Pass the secret key for the message as a parameter to the function. Arguments text : The input string secretKey : The secret key Returns The SHA-1 hash of the input string using a hash message authentication code (HMAC) Examples input {{ \"test\" | string.hmac_sha1 \"secret\" }} output 1aa349585ed7ecbd3b9c486a30067e395ca4b356 :top: string.hmac_sha256 string.hmac_sha256 <text> <secretKey> Description Converts a string into a SHA-256 hash using a hash message authentication code (HMAC). Pass the secret key for the message as a parameter to the function. Arguments text : The input string secretKey : The secret key Returns The SHA-256 hash of the input string using a hash message authentication code (HMAC) Examples input {{ \"test\" | string.hmac_sha256 \"secret\" }} output 0329a06b62cd16b33eb6792be8c60b158d89a2ee3a876fce9a881ebb488c0914 :top: string.pad_left string.pad_left <text> <width> Description Pads a string with leading spaces to a specified total length. Arguments text : The input string width : The number of characters in the resulting string Returns The input string padded Examples input hello{{ \"world\" | string.pad_left 10 }} output hello world :top: string.pad_right string.pad_right <text> <width> Description Pads a string with trailing spaces to a specified total length. Arguments text : The input string width : The number of characters in the resulting string Returns The input string padded Examples input {{ \"hello\" | string.pad_right 10 }}world output hello world :top: string.base64_encode string.base64_encode <text> Description Encodes a string to its Base64 representation. Its character encoded will be UTF-8. Arguments text : The string to encode Returns The encoded string Examples input {{ \"hello\" | string.base64_encode }} output aGVsbG8= :top: string.base64_decode string.base64_decode <text> Description Decodes a Base64-encoded string to a byte array. he encoding of the bytes is assumed to be UTF-8. Arguments text : The string to decode Returns The decoded string Examples input {{ \"aGVsbG8=\" | string.base64_decode }} output hello :top: timespan functions A timespan object represents a time interval. Name Description .days Gets the number of days of this interval .hours Gets the number of hours of this interval .minutes Gets the number of minutes of this interval .seconds Gets the number of seconds of this interval .milliseconds Gets the number of milliseconds of this interval .total_days Gets the total number of days in fractional part .total_hours Gets the total number of hours in fractional part .total_minutes Gets the total number of minutes in fractional part .total_seconds Gets the total number of seconds in fractional part .total_milliseconds Gets the total number of milliseconds in fractional part timespan.from_days timespan.from_hours timespan.from_minutes timespan.from_seconds timespan.from_milliseconds timespan.parse :top: timespan.from_days timespan.from_days <days> Description Returns a timespan object that represents a days interval Arguments days : The days. Returns A timespan object Examples input {{ (timespan.from_days 5).days }} output 5 :top: timespan.from_hours timespan.from_hours <hours> Description Returns a timespan object that represents a hours interval Arguments hours : The hours. Returns A timespan object Examples input {{ (timespan.from_hours 5).hours }} output 5 :top: timespan.from_minutes timespan.from_minutes <minutes> Description Returns a timespan object that represents a minutes interval Arguments minutes : The minutes. Returns A timespan object Examples input {{ (timespan.from_minutes 5).minutes }} output 5 :top: timespan.from_seconds timespan.from_seconds <seconds> Description Returns a timespan object that represents a seconds interval Arguments seconds : The seconds. Returns A timespan object Examples input {{ (timespan.from_seconds 5).seconds }} output 5 :top: timespan.from_milliseconds timespan.from_milliseconds <millis> Description Returns a timespan object that represents a milliseconds interval Arguments millis : The milliseconds. Returns A timespan object Examples input {{ (timespan.from_milliseconds 5).milliseconds }} output 5 :top: timespan.parse timespan.parse <text> Description Parses the specified input string into a timespan object. Arguments text : A timespan text Returns A timespan object parsed from timespan Examples Note: This document was automatically generated from the sourcecode using Scriban.DocGen program","title":"Builtins"},{"location":"builtins/#builtins","text":"This document describes the various built-in functions available in scriban. array functions date functions html functions math functions object functions regex functions string functions timespan functions :top:","title":"Builtins"},{"location":"builtins/#array-functions","text":"Array functions available through the object 'array' in scriban. array.add array.add_range array.compact array.concat array.cycle array.each array.filter array.first array.insert_at array.join array.last array.limit array.map array.offset array.remove_at array.reverse array.size array.sort array.uniq array.contains","title":"array functions"},{"location":"builtins/#arrayadd","text":"array.add <list> <value>","title":"array.add"},{"location":"builtins/#arrayadd_range","text":"array.add_range <list1> <list2>","title":"array.add_range"},{"location":"builtins/#arraycompact","text":"array.compact <list>","title":"array.compact"},{"location":"builtins/#arrayconcat","text":"array.concat <list1> <list2>","title":"array.concat"},{"location":"builtins/#arraycycle","text":"array.cycle <list> <group>?","title":"array.cycle"},{"location":"builtins/#arrayeach","text":"array.each <list> <function>","title":"array.each"},{"location":"builtins/#arrayfilter","text":"array.filter <list> <function>","title":"array.filter"},{"location":"builtins/#arrayfirst","text":"array.first <list>","title":"array.first"},{"location":"builtins/#arrayinsert_at","text":"array.insert_at <list> <index> <value>","title":"array.insert_at"},{"location":"builtins/#arrayjoin","text":"array.join <list> <delimiter> <function>?","title":"array.join"},{"location":"builtins/#arraylast","text":"array.last <list>","title":"array.last"},{"location":"builtins/#arraylimit","text":"array.limit <list> <count>","title":"array.limit"},{"location":"builtins/#arraymap","text":"array.map <list> <member>","title":"array.map"},{"location":"builtins/#arrayoffset","text":"array.offset <list> <index>","title":"array.offset"},{"location":"builtins/#arrayremove_at","text":"array.remove_at <list> <index>","title":"array.remove_at"},{"location":"builtins/#arrayreverse","text":"array.reverse <list>","title":"array.reverse"},{"location":"builtins/#arraysize","text":"array.size <list>","title":"array.size"},{"location":"builtins/#arraysort","text":"array.sort <list> <member>?","title":"array.sort"},{"location":"builtins/#arrayuniq","text":"array.uniq <list>","title":"array.uniq"},{"location":"builtins/#arraycontains","text":"array.contains <list> <item>","title":"array.contains"},{"location":"builtins/#date-functions","text":"A datetime object represents an instant in time, expressed as a date and time of day. Name Description .year Gets the year of a date object .month Gets the month of a date object .day Gets the day in the month of a date object .day_of_year Gets the day within the year .hour Gets the hour of the date object .minute Gets the minute of the date object .second Gets the second of the date object .millisecond Gets the millisecond of the date object","title":"date functions"},{"location":"builtins/#datenow","text":"date.now","title":"date.now"},{"location":"builtins/#dateadd_days","text":"date.add_days <date> <days>","title":"date.add_days"},{"location":"builtins/#dateadd_months","text":"date.add_months <date> <months>","title":"date.add_months"},{"location":"builtins/#dateadd_years","text":"date.add_years <date> <years>","title":"date.add_years"},{"location":"builtins/#dateadd_hours","text":"date.add_hours <date> <hours>","title":"date.add_hours"},{"location":"builtins/#dateadd_minutes","text":"date.add_minutes <date> <minutes>","title":"date.add_minutes"},{"location":"builtins/#dateadd_seconds","text":"date.add_seconds <date> <seconds>","title":"date.add_seconds"},{"location":"builtins/#dateadd_milliseconds","text":"date.add_milliseconds <date> <millis>","title":"date.add_milliseconds"},{"location":"builtins/#dateparse","text":"date.parse <text>","title":"date.parse"},{"location":"builtins/#dateto_string","text":"date.to_string <datetime> <pattern> <culture>","title":"date.to_string"},{"location":"builtins/#html-functions","text":"Html functions available through the builtin object 'html'. html.strip html.escape html.url_encode html.url_escape","title":"html functions"},{"location":"builtins/#htmlstrip","text":"html.strip <text>","title":"html.strip"},{"location":"builtins/#htmlescape","text":"html.escape <text>","title":"html.escape"},{"location":"builtins/#htmlurl_encode","text":"html.url_encode <text>","title":"html.url_encode"},{"location":"builtins/#htmlurl_escape","text":"html.url_escape <text>","title":"html.url_escape"},{"location":"builtins/#math-functions","text":"Math functions available through the object 'math' in scriban. math.abs math.ceil math.divided_by math.floor math.format math.is_number math.minus math.modulo math.plus math.round math.times math.uuid math.random","title":"math functions"},{"location":"builtins/#mathabs","text":"math.abs <value>","title":"math.abs"},{"location":"builtins/#mathceil","text":"math.ceil <value>","title":"math.ceil"},{"location":"builtins/#mathdivided_by","text":"math.divided_by <value> <divisor>","title":"math.divided_by"},{"location":"builtins/#mathfloor","text":"math.floor <value>","title":"math.floor"},{"location":"builtins/#mathformat","text":"math.format <value> <format> <culture>?","title":"math.format"},{"location":"builtins/#mathis_number","text":"math.is_number <value>","title":"math.is_number"},{"location":"builtins/#mathminus","text":"math.minus <value> <with>","title":"math.minus"},{"location":"builtins/#mathmodulo","text":"math.modulo <value> <with>","title":"math.modulo"},{"location":"builtins/#mathplus","text":"math.plus <value> <with>","title":"math.plus"},{"location":"builtins/#mathround","text":"math.round <value> <precision: 0>?","title":"math.round"},{"location":"builtins/#mathtimes","text":"math.times <value> <with>","title":"math.times"},{"location":"builtins/#mathuuid","text":"math.uuid","title":"math.uuid"},{"location":"builtins/#mathrandom","text":"math.random <minValue> <maxValue>","title":"math.random"},{"location":"builtins/#object-functions","text":"Object functions available through the builtin object 'object'. object.default object.eval object.eval_template object.format object.has_key object.has_value object.keys object.size object.typeof object.kind object.values :top:","title":"object functions"},{"location":"builtins/#objectdefault","text":"object.default <value> <default>","title":"object.default"},{"location":"builtins/#objecteval","text":"object.eval <value>","title":"object.eval"},{"location":"builtins/#objecteval_template","text":"object.eval_template <value>","title":"object.eval_template"},{"location":"builtins/#objectformat","text":"object.format <value> <format> <culture>?","title":"object.format"},{"location":"builtins/#objecthas_key","text":"object.has_key <value> <key>","title":"object.has_key"},{"location":"builtins/#objecthas_value","text":"object.has_value <value> <key>","title":"object.has_value"},{"location":"builtins/#objectkeys","text":"object.keys <value>","title":"object.keys"},{"location":"builtins/#objectsize","text":"object.size <value>","title":"object.size"},{"location":"builtins/#objecttypeof","text":"object.typeof <value>","title":"object.typeof"},{"location":"builtins/#objectkind","text":"object.kind <value>","title":"object.kind"},{"location":"builtins/#objectvalues","text":"object.values <value>","title":"object.values"},{"location":"builtins/#regex-functions","text":"Functions exposed through regex builtin object. regex.escape regex.match regex.matches regex.replace regex.split regex.unescape :top:","title":"regex functions"},{"location":"builtins/#regexescape","text":"regex.escape <pattern>","title":"regex.escape"},{"location":"builtins/#regexmatch","text":"regex.match <text> <pattern> <options>?","title":"regex.match"},{"location":"builtins/#regexmatches","text":"regex.matches <text> <pattern> <options>?","title":"regex.matches"},{"location":"builtins/#regexreplace","text":"regex.replace <text> <pattern> <replace> <options>?","title":"regex.replace"},{"location":"builtins/#regexsplit","text":"regex.split <text> <pattern> <options>?","title":"regex.split"},{"location":"builtins/#regexunescape","text":"regex.unescape <pattern>","title":"regex.unescape"},{"location":"builtins/#string-functions","text":"String functions available through the builtin object 'string`. string.escape string.append string.capitalize string.capitalizewords string.contains string.empty string.whitespace string.downcase string.ends_with string.handleize string.literal string.lstrip string.pluralize string.prepend string.remove string.remove_first string.replace string.replace_first string.rstrip string.size string.slice string.slice1 string.split string.starts_with string.strip string.strip_newlines string.to_int string.to_long string.to_float string.to_double string.truncate string.truncatewords string.upcase string.md5 string.sha1 string.sha256 string.hmac_sha1 string.hmac_sha256 string.pad_left string.pad_right string.base64_encode string.base64_decode :top:","title":"string functions"},{"location":"builtins/#stringescape","text":"string.escape <text>","title":"string.escape"},{"location":"builtins/#stringappend","text":"string.append <text> <with>","title":"string.append"},{"location":"builtins/#stringcapitalize","text":"string.capitalize <text>","title":"string.capitalize"},{"location":"builtins/#stringcapitalizewords","text":"string.capitalizewords <text>","title":"string.capitalizewords"},{"location":"builtins/#stringcontains","text":"string.contains <text> <value>","title":"string.contains"},{"location":"builtins/#stringempty","text":"string.empty <text>","title":"string.empty"},{"location":"builtins/#stringwhitespace","text":"string.whitespace <text>","title":"string.whitespace"},{"location":"builtins/#stringdowncase","text":"string.downcase <text>","title":"string.downcase"},{"location":"builtins/#stringends_with","text":"string.ends_with <text> <value>","title":"string.ends_with"},{"location":"builtins/#stringhandleize","text":"string.handleize <text>","title":"string.handleize"},{"location":"builtins/#stringliteral","text":"string.literal <text>","title":"string.literal"},{"location":"builtins/#stringlstrip","text":"string.lstrip <text>","title":"string.lstrip"},{"location":"builtins/#stringpluralize","text":"string.pluralize <number> <singular> <plural>","title":"string.pluralize"},{"location":"builtins/#stringprepend","text":"string.prepend <text> <by>","title":"string.prepend"},{"location":"builtins/#stringremove","text":"string.remove <text> <remove>","title":"string.remove"},{"location":"builtins/#stringremove_first","text":"string.remove_first <text> <remove>","title":"string.remove_first"},{"location":"builtins/#stringreplace","text":"string.replace <text> <match> <replace>","title":"string.replace"},{"location":"builtins/#stringreplace_first","text":"string.replace_first <text> <match> <replace>","title":"string.replace_first"},{"location":"builtins/#stringrstrip","text":"string.rstrip <text>","title":"string.rstrip"},{"location":"builtins/#stringsize","text":"string.size <text>","title":"string.size"},{"location":"builtins/#stringslice","text":"string.slice <text> <start> <length>?","title":"string.slice"},{"location":"builtins/#stringslice1","text":"string.slice1 <text> <start> <length: 1>?","title":"string.slice1"},{"location":"builtins/#stringsplit","text":"string.split <text> <match>","title":"string.split"},{"location":"builtins/#stringstarts_with","text":"string.starts_with <text> <value>","title":"string.starts_with"},{"location":"builtins/#stringstrip","text":"string.strip <text>","title":"string.strip"},{"location":"builtins/#stringstrip_newlines","text":"string.strip_newlines <text>","title":"string.strip_newlines"},{"location":"builtins/#stringto_int","text":"string.to_int <text>","title":"string.to_int"},{"location":"builtins/#stringto_long","text":"string.to_long <text>","title":"string.to_long"},{"location":"builtins/#stringto_float","text":"string.to_float <text>","title":"string.to_float"},{"location":"builtins/#stringto_double","text":"string.to_double <text>","title":"string.to_double"},{"location":"builtins/#stringtruncate","text":"string.truncate <text> <length> <ellipsis>?","title":"string.truncate"},{"location":"builtins/#stringtruncatewords","text":"string.truncatewords <text> <count> <ellipsis>?","title":"string.truncatewords"},{"location":"builtins/#stringupcase","text":"string.upcase <text>","title":"string.upcase"},{"location":"builtins/#stringmd5","text":"string.md5 <text>","title":"string.md5"},{"location":"builtins/#stringsha1","text":"string.sha1 <text>","title":"string.sha1"},{"location":"builtins/#stringsha256","text":"string.sha256 <text>","title":"string.sha256"},{"location":"builtins/#stringhmac_sha1","text":"string.hmac_sha1 <text> <secretKey>","title":"string.hmac_sha1"},{"location":"builtins/#stringhmac_sha256","text":"string.hmac_sha256 <text> <secretKey>","title":"string.hmac_sha256"},{"location":"builtins/#stringpad_left","text":"string.pad_left <text> <width>","title":"string.pad_left"},{"location":"builtins/#stringpad_right","text":"string.pad_right <text> <width>","title":"string.pad_right"},{"location":"builtins/#stringbase64_encode","text":"string.base64_encode <text>","title":"string.base64_encode"},{"location":"builtins/#stringbase64_decode","text":"string.base64_decode <text>","title":"string.base64_decode"},{"location":"builtins/#timespan-functions","text":"A timespan object represents a time interval. Name Description .days Gets the number of days of this interval .hours Gets the number of hours of this interval .minutes Gets the number of minutes of this interval .seconds Gets the number of seconds of this interval .milliseconds Gets the number of milliseconds of this interval .total_days Gets the total number of days in fractional part .total_hours Gets the total number of hours in fractional part .total_minutes Gets the total number of minutes in fractional part .total_seconds Gets the total number of seconds in fractional part .total_milliseconds Gets the total number of milliseconds in fractional part timespan.from_days timespan.from_hours timespan.from_minutes timespan.from_seconds timespan.from_milliseconds timespan.parse :top:","title":"timespan functions"},{"location":"builtins/#timespanfrom_days","text":"timespan.from_days <days>","title":"timespan.from_days"},{"location":"builtins/#timespanfrom_hours","text":"timespan.from_hours <hours>","title":"timespan.from_hours"},{"location":"builtins/#timespanfrom_minutes","text":"timespan.from_minutes <minutes>","title":"timespan.from_minutes"},{"location":"builtins/#timespanfrom_seconds","text":"timespan.from_seconds <seconds>","title":"timespan.from_seconds"},{"location":"builtins/#timespanfrom_milliseconds","text":"timespan.from_milliseconds <millis>","title":"timespan.from_milliseconds"},{"location":"builtins/#timespanparse","text":"timespan.parse <text>","title":"timespan.parse"},{"location":"language/","text":"Language This document describes the syntax of the scriban language in a templating context (within {{ and }} ). The language rules are the same in a pure scripting context. Note This document does not describe the liquid language. Check the liquid website directly. 1. Blocks There are 3 types of block of text in a template: Code block : contains scriban template statements Text block : a plain block to output as is Escape block : a text block that can escape code blocks :top: 1.1 Code block A text enclosed by {{ and }} is a scriban code block that will be evaluated by the scriban templating engine. A scriban code block may contain: a single line expression statement : {{ name }} or a multiline statements : {{ if !name name = \"default\" end name }} or statements separated by a semi-colon ; to allow compact forms in some use cases: {{if !name; name = \"default\"; end; name }} Inside a code block, except for the EOL after each statement, white spaces characters are not affecting the parsing. There is only one case where whitespace is used to disambiguate between an array indexer and an array initializer. Also, if a statement is an expression (but not an assignment expression), the result of the expression will be output to the rendering output of the template: input {{ x = \"5\" # This assignment will not output anything x # This expression will print 5 x + 1 # This expression will print 6 }} output 56 Note that in the previous example, there is no EOL between 5 and 6 because we are inside a code block. You can still use a plain string with an EOL inside a code block \"\\n\" or you could use mixed code and text blocks: input {{ x = \"5\" }} {{ x }} {{ x + 1 }} output 5 6 :top: 1.2 Text block Otherwise, any text is considered as a text block and simply output as is Hello this is {{ name }}, welcome to scriban! ______________ _____________________ ^ text block ^ text block :top: 1.3 Escape block Any code and text block can be escaped to produce a text block by enclosing it with {%{ and }%} For example the following escape: input : {%{Hello this is {{ name }}}%} output : Hello this is {{ name }} Any escape block can be also escaped by increasing the number of % in the starting and ending block: input : {%%{This is an escaped block: }%} here}%%} output : This is an escaped block: }%} here This allow effectively to nest escape blocks and still be able to escape them. Hence a starting escape block {%%%%{ will required an ending }%%%%} :top: 1.4 Whitespace control By default, any whitespace (including new lines) before or after a code/escape block are copied as-is to the output. Scriban provides two modes for controlling whitespace: The greedy mode using the character - (e.g {{- or -}} ), removes any whitespace, including newlines Examples with the variable name = \"foo\" : Strip whitespace on the left: > input This is a < {{- name}}> text > output This is a < foo > a text Strip on the right: > input This is a <{{ name -}} > text: > output This is a < foo > text Strip on both left and right: > input This is a < {{- name -}} > text: > output This is a < foo > text The non greedy mode using the character ~ Using a {{~ will remove any whitespace before but will stop on the first newline without including it Using a ~}} will remove any whitespace after including the first newline but will stop after This mode is very convenient when you want to use only a scriban statement on a line, but want that line to be completely removed from the output, but to keep spaces before and after this line intact. In the following example, we want to remove entirely the lines {{~ for product in products ~}} and {{~ end ~}} , but we want for example to keep the indentation of the opening <li> . Using the greedy mode {{- or -}} would have removed all whitespace and lines and would have put the results on a single line. input <ul> {{~ for product in products ~}} <li>{{ product.name }}</li> {{~ end ~}} </ul> output <ul> <li>Orange</li> <li>Banana</li> <li>Apple</li> </ul> Both mode ~ and '-' can also be used with escape blocks {%%{~ or ~}%%} or {%%{- or -}%%} :top: 2 Comments Within a code block, scriban supports single line comments # and multi-line comments ## : {{ name # this is a single line comment }} input {{ ## This is a multi line comment ## }} output As you can notice, both single line and multi-line comments can be closed by the presence of a code block exit tag }} :top: 3 Literals 3.1 Strings Scriban supports two types of strings: regular strings enclosed by double quotes \"...\" or simple quotes '...' . Regular strings supports multiline and will interpret the following escape sequences: \\' single quote \\\" double quote \\\\ backslash \\n new line \\r carriage return \\t tab \\b backspace \\f form feed \\uxxxx where xxxx is a unicode hexa code number 0000 to ffff \\x00-\\xFF a hexadecimal ranging from 0x00 to 0xFF verbatim strings enclosed by backstick quotes `...` . They are, for example, useful to use with for regex patterns : input {{ \"this is a text\" | regex.split `\\s+` }} output [this, is, a, test] :top: 3.2 Numbers A number in scriban {{ 100 }} is similar to a javascript number: Integers: 100 , 1e3 Hexadecimal integers: 0x1ef and unsigned 0x80000000u Floats: 100.0 , 1.0e3 , 1.0e-3 32-bit floats: 100.0f 64-bit floats: 100.0d 128-bit decimals: 100.0m :top: 3.3 Boolean The boolean value {{ true }} or {{ false }} input {{ true }} {{ false }} output true false :top: 3.4 null The null value {{ null }} When resolving to a string output, the null value will output an empty string: input {{ null }} output :top: 4 Variables Scriban supports the concept of global and local variables A global/property variable like {{ name }} is a liquid like handle, starting by a letter or underscore _ and following by a letter A-Z a-z , a digit 0-9 , an underscore _ The following text are valid variable names: var var9 _var NOTE: In liquid, the character - is allowed in a variable name, but when translating it to a scriban, you will have to enclose it into a quoted string A local variable like {{ $name }} is an identifier starting with $ . A local variable is only accessible within the same include page or function body. The special local variable $ alone is an array containing the arguments passed to the current function or include page. The special local variables $0 $1 ... $n is a shorthand of $[0] , $[1] ... $[n] . e.g Using $0 returns the first argument of the current function or including page. 4.1 The special variable this The this variable gives you access to the current object bound where you have access to all local variables for the current scope. Thus the following variable access are equivalent: input {{ a = 5 a # output 5 this.a = 6 a # output 6 this[\"a\"] = 7 a # output 7 }} output 567 In the case of the with statement, the this operator refers to the object passed to with : input {{ a = {x: 1, y: 2} with a b = this end b.x }} output 1 :top: 4.2 The special variable empty The empty variable represents simply an empty object. It is mainly relevant to be compatible with liquid, by providing a way to compare an object with the empty object to check if it is empty or not: input {{ a = {} b = [1, 2]~}} {{a == empty}} {{b == empty}} output true false :top: 5 Objects Scriban supports javascript like objects {...} An object can be initialized empty : {{ myobject = {} }} An object can be initialized with some members: {{ myobject = { member1: \"yes\", member2: \"no\" } }} or use a json syntax: {{ myobject = { \"member1\": \"yes\", \"member2\": \"no\" } }} An object can be initialized with some members over multiple lines: {{ myobject = { member1: \"yes\", member2: \"no\" } }} Members of an object can be accessed: {{ myobject.member1 }} also equivalent to {{ myobject[\"member1\"] }} You can access optional members in chain via the optional member operator ?. (instead of the regular member operator: . ) ( New in 3.0 ) {{ myobject.member1?.submember1?.submember2 ?? \"nothing\" }} will return \"nothing\" as member1 doesn't contain a submember1 / submember2 . If the object is a \"pure\" scriban objects (created with a {...} or instantiated by the runtime as a ScriptObject ), you can also add members to it with a simple assignment: input {{ myobject = {} myobject.member3 = \"may be\" myobject.member3 }} output may be NOTICE By default, Properties and methods of .NET objects are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. If you want to change this behavior, you need to use a MemberRenamer delegate 5.1 The special property empty? Any object can respond the the property .empty? to check if it is empty or not: input {{ a = {} b = [1, 2]~}} {{a.empty?}} {{b.empty?}} output true false :top: 6 Arrays An array can be initialized empty : {{ myarray = [] }} An array can be initialized with some items: {{ myarray = [1, 2, 3, 4] }} An array can be initialized with some items over multiple lines: {{ myarray = [ 1, 2, 3, 4, ] }} Items of an array can be zero-based indexed: {{ myarray[0] }} If the array is a \"pure\" scriban array (created with a [...] or instantiated by the runtime as a ScriptArray ), you can also add items to it with a simple assignment that will expand automatically the array depending on the index: {{ myarray = [] myarray[0] = 1 myarray[1] = 2 myarray[2] = 3 myarray[3] = 4 }} You can also manipulate arrays with the array builtin object . Important notice While whitespace characters are mostly not relevant while parsing in scriban, there is a case where a whitespace helps to disambiguate between an array indexer and an array initializer . For instance, if a whitespace is found before a [ and the previous expression was a variable path expressions (see later), the following expression [...] will be considered as an array initializer instead of an array indexer: {{ myfunction [1] # There is a whitespace after myfunction. # It will result in a call to myfunction passing an array as an argument myvariable[1] # Without a whitespace, this is accessing # an element in the array provided by myvariable }} 6.1 Array with properties An array can also contains attached properties: input {{ a = [5, 6, 7] a.x = \"yes\" a.x + a[0] }} output yes5 :top: 6.2 The special size property Arrays have a size property that can be used to query the number of elements in the array: input {{ a = [1, 2, 3] a.size }} output 3 :top: 7 Functions Scriban allows to define 4 kind of functions: Simple functions Anonymous functions Parametric functions ( New in 3.0 ) Inline functions ( New in 3.0 ) 7.1 Simple functions The following declares a function sub that uses its first argument and subtract from it the second argument: {{func sub ret $0 - $1 end}} All argument are passed to the special variable $ that will contain the list of direct arguments and named arguments: $0 or $[0] will access the first argument $1 or $[1] will access the second argument $[-1] will access the last argument $.named will access the named argument named This function can then be used: input {{sub 5 1}} {{5 | sub 1}} output 4 4 As you can notice from the example above, when using the pipe, the result of the pipe is pushed as the first argument of the pipe receiver. Note that a function can have mixed text statements as well: {{func inc}} This is a text with the following argument {{ $0 + 1 }} {{end}} NOTE: Setting a non-local variable (e.g a = 10 ) in a simple function will be set at the global level and not at the function level. Parametric functions are solving this behavior by introducing a new variable scope inside the function that includes parameters. 7.2 Anonymous functions Anonymous functions are like simple functions but can be used in expressions (e.g as the last argument of function call) input {{ sub = do; ret $0 - $1; end; 1 | sub 3 }} output -2 They are very convenient to build custom block functions: input {{ func launch; ret $0 1 2; end launch do ret $0 + $1 end }} output 3 7.3 Parametric functions They are similar to simple functions but they are declared with parenthesis, while also supporting declaration of different kind of parameters (normal, optional, variable). Another difference with simple functions is that they require function calls and arguments to match the expected function parameters. A function with normal parameters: {{func sub(x,y) ret x - y end}} input {{sub 5 1}} {{5 | sub 1}} output 4 4 A function with normal parameters and optional parameters with default values: {{func sub_opt(x, y, z = 1, w = 2) ret x - y - z - w end}} input {{sub_opt 5 1}} {{5 | sub_opt 1}} output 1 1 Here we override the value of z and set it to 0 instead of default 1 : input {{sub_opt 5 1 0 }} {{5 | sub_opt 1 0}} output 2 2 A function with normal parameters and optional parameters with default values: {{func sub_variable(x, y...) ret x - (y[0] ?? 0) - (y[1] ?? 0) end}} input {{sub_variable 5 1 -1} {{5 | sub_variable 1 -1}} output 5 5 NOTE: The special variable $ is still accessible in parametric functions and represent the direct list of arguments. In the example above, $ = [5, [1, -1]] 7.4 Inline functions For simple functions, it is convenient to define simple functions like mathematical functions: {{ sub(x,y) = x - y }} Inline functions are similar to parametric functions but they only support normal parameters. They don't support optional or variable parameters. 7.5 Function Pointers Because functions are object, they can be stored into a property of an object by using the alias @ operator: {{ myobject.myinc = @inc # Use the @ alias operator to allow to # use a function without evaluating it x = 1 | myobject.myinc # x = x + 1 }} The function aliasing operator @ allows to pass a function as a parameter to another function, enabling powerful function compositions. :top: 8 Expressions Scriban supports conventional unary and binary expressions. :top: 8.1 Variable path expressions A variable path expression contains the path to a variable: A simple variable access: {{ name }} e.g resolve to the top level variable name An array access: {{ myarray[1] }} e.g resolve to the top level variable myarray and an indexer to the array A member access: {{ myobject.member1.myarray[2] }} e.g resolve to the top level variable myobject , then the property member1 this object, the property myarray and an indexer to the array returned by myarray Note that a variable path can either point to a simple variable or can result into calling a parameter less function. :top: 8.2 Assign expression A value can be assigned to a top level variable or to the member of an object/array: {{ name = \"foo\" }} e.g Assign the string \"foo\" the variable name {{ myobject.member1.myarray[0] = \"foo\" }} An assign expression must be a top level expression statement and cannot be used within a sub-expression. :top: 8.3 Nested expression An expression enclosed by ( and ) {{ name = ('foo' + 'bar') }} :top: 8.4 Arithmetic expressions On numbers The following binary operators are supported for numbers : Operator Description <left> + <right> add left to right number <left> - <right> substract right number from left <left> * <right> multiply left by right number <left> / <right> divide left by right number <left> // <right> divide left by right number and round to an integer <left> % <right> calculates the modulus of left by right If left or right is a float and the other is an integer, the result of the operation will be a float. :top: On strings The following binary operators are supported for strings : Operator Description 'left' + <right> concatenates left to right string: \"ab\" + \"c\" -> \"abc\" 'left' * <right> concatenates the left string right times: 'a' * 5 -> aaaaa . left and right and be swapped as long as there is one string and one number. As long as there is a string in a binary operation, the other part will be automatically converted to a string. The following literals are converted to plain strings: null -> \"\" . e.g: \"aaaa\" + null -> \"aaaa\" 0 -> \"0\" 1.0 -> \"1.0\" true -> \"true\" false -> \"false\" :top: 8.5 Conditional expressions A boolean expression produces a boolean by comparing a left and right value. Operator Description <left> == <right> Is left equal to right? <left> != <right> Is left not equal to right? <left> > <right> Is left greater than right? <left> >= <right> Is left greater or equal to right? <left> < <right> Is left less than right? <left> <= <right> Is left less or equal to right? They work with both numbers , strings and datetimes. You can combine conditional expressions with && (and operator) and || (or operator). Unlike in javascript it always returns boolean and never <left> or <right> . Operator Description <left> && <right> Is left true and right true? <left> \\|\\| <right> Is left true or right true? The conditional expression cond ? left : right allow to return left if cond is true otherwise right . ( New in 3.0 ) :top: 8.6 Unary expressions Operator Description ! <expression> Boolean negate an expression. e.g if !page + <expression> Arithmetic positive an expression. e.g +1.5 - <expression> Arithmetic negate an expression ^ <expression> Expand an array passed to arguments of a function call (see function call) @ <expression> Alias the result of an expression that would be evaluated if it was a function call :top: 8.7 Range expressions They are special binary expressions that provides an iterator (used usually with the for statement) The evaluated left and right expressions must resolve to an integer at runtime. Operator Description left..right Returns an iterator between left and right with a step of 1, including right . e.g: 1..5 iterates from 1 to 5 left..<right Returns an iterator between left and right with a step of 1, excluding right . e.g: 1..<5 iterates from 1 to 4 8.8 The null-coalescing operator ?? The operator left ?? right can be used to return the right value if left is null. :top: 8.9 Function call expression A function can be called by passing parameters separated by a whitespace: {{ myfunction arg1 \"arg2\" (1+5) }} The pipe operator | can also be used to pipe the result of an expression to a function: {{ date.parse '2016/01/05' | date.to_string '%g' }} will output 06 Jan 2016 Notice that when a function receives the result of a pipe call (e.g date.to_string in the example above), it is passed as the first argument of the call . This is valid for both .NET custom functions as well as for Scriban integrated functions. Pipes are greedy with respect to whitespace. This allow them to be chained across multiple lines: {{- \"text\" | string.append \"END\" | string.prepend \"START\" -}} will output STARTtextEND Named arguments When passing multiple arguments to an existing .NET function, you may want to use named arguments. Suppose you have declared a .NET function like this: public static string MyProcessor ( string left , string right , int count , string options = null ) { // ... } You can call this function from scriban with the following syntax: {{ my_processor \"Hello\" \"World\" count: 15 options: \"optimized\" }} with a pipe we could rewrite this to: {{ \"Hello\" | my_processor \"World\" count: 15 options: \"optimized\" }} Note that once arguments are named, the following arguments must be all named. In a custom function declared with func named arguments are accessible through the variable arguments variable $ , but as properties (and not as part of the default array arguments): input {{ func my_processor \"Argument count:\" + $.count \"Argument options:\" + $[\"options\"] for $x in $ \"arg[\" + $x + \"]: \" + $x end end my_processor \"Hello\" \"World\" count: 15 options: \"optimized\" }} output Argument count: 15 Argument options: optimized arg[0]: Hello arg[1]: World :top: 9 Statements Each statement must be terminated by a code block }} or an EOL within a code block, or a semicolon to separate multiple statements on a single line within a code block. :top: 9.1 Single expression An expression statement: {{ value + 1 }} e.g Evaluates value + 1 and output the result {{ value + 1 # This is a single line expression statement followed by this comment }} :top: 9.2 if <expression> , else , else if <expression> The general syntax is: {{ if <expression> ... else if <expression> ... else ... end }} An if statement must be closed by an end or followed by a else or else if statement. An else or else if statement must be followed by a else , else if or closed by an end statement. An expression evaluated for a if or else if will be converted to a boolean. Truthy and Falsy By default, only the null and boolean false are considered as false when evaluated as booleans. The following values are used for converting literals to boolean: 0 -> true 1 -> true or any non zero value null -> false false -> false non_null_object -> true \"\" -> true An empty string returns true \"foo\" -> true Example testing a page object: {{ if page }}Page is not null{{ else }}Page is null!{{ end }} :top: 9.3 case and when This is the equivalent of switch statement in C#, a selection statement that chooses a single switch section to execute from a list of candidates based on a value matching. case <expression> opens a switch with an expression when <match> allows to match with the specified expression and the case expression when can also be used with multiple values separated by , or || A final else can be used to as a default handler in case nothing matched. input {{ x = 5 case x when 1, 2, 3 \"Value is 1 or 2 or 3 when 5 \"Value is 5\" else \"Value is \" + x end }} output Value is 5 :top: 9.3 Loops for <variable> in <expression> ... end {{for <variable> in <expression>}} ... {{end}} The expression can be an array or a range iterator: Loop on an array: {{ for page in pages }}This is the page {{ page.title }}{{ end }} Loop on a range: {{ for x in 1..n }}This is the loop step [{{x}}]{{ end }} The for loop (along with the tablerow statement below) supports additional parameters, offset , limit and reversed that can also be used togethers: The offset parameter Allows to start the iteration of the loop at the specified zero-based index: input {{~ for $i in 4..9 offset:2 ~}} {{ $i }} {{~ endfor ~}} output 6 7 8 9 The limit parameter Allows to limit the iteration of the loop for the specified count input {{~ for $i in 4..9 limit:2 ~}} {{ $i }} {{~ endfor ~}} output 4 5 The reversed parameter Allows to reverse the iteration on the elements input {{~ for $i in 1..3 reversed ~}} {{ $i }} {{~ endfor ~}} output 3 2 1 :top: while <expression> ... end {{while <expression>}} ... {{end}} Like the if statement, the expression is evaluated to a boolean. tablerow <variable> in <expression> ... end This function generates HTML rows compatible with an HTML table. Must be wrapped in an opening <table> and closing </table> HTML tags. This statement is mainly for compatibility reason with the liquid tablerow tag. It has overall the same syntax as a for statement (supporting the same parameters). {{tablerow <variable> in <expression>}} ... {{end}} input <table> {{~ tablerow $p in products | array.sort \"title\" -}} {{ $p.title -}} {{ end ~}} </table> output < table > < tr class = \"row1\" >< td class = \"col1\" > Apple </ td ></ tr > < tr class = \"row2\" >< td class = \"col1\" > Banana </ td ></ tr > < tr class = \"row3\" >< td class = \"col1\" > Computer </ td ></ tr > < tr class = \"row4\" >< td class = \"col1\" > Mobile Phone </ td ></ tr > < tr class = \"row5\" >< td class = \"col1\" > Orange </ td ></ tr > < tr class = \"row6\" >< td class = \"col1\" > Sofa </ td ></ tr > < tr class = \"row7\" >< td class = \"col1\" > Table </ td ></ tr > </ table > The cols parameter Defines the number of columns to output: input <table> {{~ tablerow $p in (products | array.sort \"title\") limit: 4 cols: 2 -}} {{ $p.title -}} {{ end ~}} </table> output < table > < tr class = \"row1\" >< td class = \"col1\" > Apple </ td >< td class = \"col2\" > Banana </ td ></ tr > < tr class = \"row2\" >< td class = \"col1\" > Computer </ td >< td class = \"col2\" > Mobile Phone </ td ></ tr > </ table > :top: Special loop variables The following variables are accessible within a for block: Name Description {{for.index}} The current index of the for loop {{for.rindex}} The current index of the for loop starting from the end of the list {{for.first}} A boolean indicating whether this is the first step in the loop {{for.last}} A boolean indicating whether this is the last step in the loop {{for.even}} A boolean indicating whether this is an even row in the loop {{for.odd}} A boolean indicating whether this is an odd row in the loop {{for.changed}} A boolean indicating whether a current value of this iteration changed from previous step Within a while statement, the following variables can be used: Name Description {{while.index}} The current index of the while loop {{while.first}} A boolean indicating whether this is the first step in the loop {{while.even}} A boolean indicating whether this is an even row in the loop {{while.odd}} A boolean indicating whether this is an odd row in the loop :top: break and continue The break statement allows to early exit a loop {{ for i in 1..5 if i > 2 break end end }} The continue statement allows to skip the rest of a loop and continue on the next step {{ for i in 1..5 if i == 2 continue end }} [{{i}}]] step {{ end }} Will output: [1] step [3] step [4] step [5] step :top: 9.4 capture <variable> ... end The capture <variable> ... end statement allows to capture the template output to a variable: For example the following code: {{ capture myvariable }} This is the result of a capture {{ date.now }} {{ end }} will set myvariable = \"This is the result of a capture 06 Jan 2016\\n\" :top: 9.5 readonly <variable> The readonly statement prevents a variable for subsequent assignments: {{ x = 1 }} {{ readonly x }} {{ x = 2 }} <- this will result in a runtime error :top: 9.6 import <variable_path> The import <variable_path> statement allows to import the members of an object as variables of the current bound: {{ myobject = { member1: \"yes\" } import myobject member1 # will print the \"yes\" string to the output }} Note that readonly variables won't be override. :top: 9.7 with <variable> ... end The with <variable> ... end statement will open a new object context with the passed variable, all assignment will result in setting the members of the passed object. myobject = {} with myobject member1 = \"yes\" end :top: 9.8 wrap <function> <arg1...argn> ... end Pass a block of statements to a function that will be able to evaluate it using the special variable $$ {{ func wrapped for $i in 1..<$0 $$ # This special variable evaluates the block pass # to the wrap statement end end wrap wrapped 5 $i + \" -> This is inside the wrap!\\r\\n\" end }} will output: 1 -> This is inside the wrap! 2 -> This is inside the wrap! 3 -> This is inside the wrap! 4 -> This is inside the wrap! Note that variables declared outside the with block are accessible within. :top: 9.9 include <name> arg1?...argn? The include is not a statement but actually a function that allows to parse and render the specified template name. In order to use this function, a delegate to an template loader must be setup on the TemplateOptions.TemplateLoader property passed to the Template.Parse method. include 'myinclude.html' x = include 'myinclude.html' x + \" modified\" assuming that myinclude.html is {{ y = y + 1 ~}} This is a string with the value {{ y }} will output: This is a string with the value 1 This is a string with the value 2 modified :top: 9.10 ret <expression>? The return statement is used to early exit from a top-level/include page or a function. This is a text {{~ ret ~}} This text will not appear will output: This is a text :top:","title":"Language"},{"location":"language/#language","text":"This document describes the syntax of the scriban language in a templating context (within {{ and }} ). The language rules are the same in a pure scripting context. Note This document does not describe the liquid language. Check the liquid website directly.","title":"Language"},{"location":"language/#1-blocks","text":"There are 3 types of block of text in a template: Code block : contains scriban template statements Text block : a plain block to output as is Escape block : a text block that can escape code blocks :top:","title":"1. Blocks"},{"location":"language/#11-code-block","text":"A text enclosed by {{ and }} is a scriban code block that will be evaluated by the scriban templating engine. A scriban code block may contain: a single line expression statement : {{ name }} or a multiline statements : {{ if !name name = \"default\" end name }} or statements separated by a semi-colon ; to allow compact forms in some use cases: {{if !name; name = \"default\"; end; name }} Inside a code block, except for the EOL after each statement, white spaces characters are not affecting the parsing. There is only one case where whitespace is used to disambiguate between an array indexer and an array initializer. Also, if a statement is an expression (but not an assignment expression), the result of the expression will be output to the rendering output of the template: input {{ x = \"5\" # This assignment will not output anything x # This expression will print 5 x + 1 # This expression will print 6 }} output 56 Note that in the previous example, there is no EOL between 5 and 6 because we are inside a code block. You can still use a plain string with an EOL inside a code block \"\\n\" or you could use mixed code and text blocks: input {{ x = \"5\" }} {{ x }} {{ x + 1 }} output 5 6 :top:","title":"1.1 Code block"},{"location":"language/#12-text-block","text":"Otherwise, any text is considered as a text block and simply output as is Hello this is {{ name }}, welcome to scriban! ______________ _____________________ ^ text block ^ text block :top:","title":"1.2 Text block"},{"location":"language/#13-escape-block","text":"Any code and text block can be escaped to produce a text block by enclosing it with {%{ and }%} For example the following escape: input : {%{Hello this is {{ name }}}%} output : Hello this is {{ name }} Any escape block can be also escaped by increasing the number of % in the starting and ending block: input : {%%{This is an escaped block: }%} here}%%} output : This is an escaped block: }%} here This allow effectively to nest escape blocks and still be able to escape them. Hence a starting escape block {%%%%{ will required an ending }%%%%} :top:","title":"1.3 Escape block"},{"location":"language/#14-whitespace-control","text":"By default, any whitespace (including new lines) before or after a code/escape block are copied as-is to the output. Scriban provides two modes for controlling whitespace: The greedy mode using the character - (e.g {{- or -}} ), removes any whitespace, including newlines Examples with the variable name = \"foo\" : Strip whitespace on the left: > input This is a < {{- name}}> text > output This is a < foo > a text Strip on the right: > input This is a <{{ name -}} > text: > output This is a < foo > text Strip on both left and right: > input This is a < {{- name -}} > text: > output This is a < foo > text The non greedy mode using the character ~ Using a {{~ will remove any whitespace before but will stop on the first newline without including it Using a ~}} will remove any whitespace after including the first newline but will stop after This mode is very convenient when you want to use only a scriban statement on a line, but want that line to be completely removed from the output, but to keep spaces before and after this line intact. In the following example, we want to remove entirely the lines {{~ for product in products ~}} and {{~ end ~}} , but we want for example to keep the indentation of the opening <li> . Using the greedy mode {{- or -}} would have removed all whitespace and lines and would have put the results on a single line. input <ul> {{~ for product in products ~}} <li>{{ product.name }}</li> {{~ end ~}} </ul> output <ul> <li>Orange</li> <li>Banana</li> <li>Apple</li> </ul> Both mode ~ and '-' can also be used with escape blocks {%%{~ or ~}%%} or {%%{- or -}%%} :top:","title":"1.4 Whitespace control"},{"location":"language/#2-comments","text":"Within a code block, scriban supports single line comments # and multi-line comments ## : {{ name # this is a single line comment }} input {{ ## This is a multi line comment ## }} output As you can notice, both single line and multi-line comments can be closed by the presence of a code block exit tag }} :top:","title":"2 Comments"},{"location":"language/#3-literals","text":"","title":"3 Literals"},{"location":"language/#31-strings","text":"Scriban supports two types of strings: regular strings enclosed by double quotes \"...\" or simple quotes '...' . Regular strings supports multiline and will interpret the following escape sequences: \\' single quote \\\" double quote \\\\ backslash \\n new line \\r carriage return \\t tab \\b backspace \\f form feed \\uxxxx where xxxx is a unicode hexa code number 0000 to ffff \\x00-\\xFF a hexadecimal ranging from 0x00 to 0xFF verbatim strings enclosed by backstick quotes `...` . They are, for example, useful to use with for regex patterns : input {{ \"this is a text\" | regex.split `\\s+` }} output [this, is, a, test] :top:","title":"3.1 Strings"},{"location":"language/#32-numbers","text":"A number in scriban {{ 100 }} is similar to a javascript number: Integers: 100 , 1e3 Hexadecimal integers: 0x1ef and unsigned 0x80000000u Floats: 100.0 , 1.0e3 , 1.0e-3 32-bit floats: 100.0f 64-bit floats: 100.0d 128-bit decimals: 100.0m :top:","title":"3.2 Numbers"},{"location":"language/#33-boolean","text":"The boolean value {{ true }} or {{ false }} input {{ true }} {{ false }} output true false :top:","title":"3.3 Boolean"},{"location":"language/#34-null","text":"The null value {{ null }} When resolving to a string output, the null value will output an empty string: input {{ null }} output :top:","title":"3.4 null"},{"location":"language/#4-variables","text":"Scriban supports the concept of global and local variables A global/property variable like {{ name }} is a liquid like handle, starting by a letter or underscore _ and following by a letter A-Z a-z , a digit 0-9 , an underscore _ The following text are valid variable names: var var9 _var NOTE: In liquid, the character - is allowed in a variable name, but when translating it to a scriban, you will have to enclose it into a quoted string A local variable like {{ $name }} is an identifier starting with $ . A local variable is only accessible within the same include page or function body. The special local variable $ alone is an array containing the arguments passed to the current function or include page. The special local variables $0 $1 ... $n is a shorthand of $[0] , $[1] ... $[n] . e.g Using $0 returns the first argument of the current function or including page.","title":"4 Variables"},{"location":"language/#41-the-special-variable-this","text":"The this variable gives you access to the current object bound where you have access to all local variables for the current scope. Thus the following variable access are equivalent: input {{ a = 5 a # output 5 this.a = 6 a # output 6 this[\"a\"] = 7 a # output 7 }} output 567 In the case of the with statement, the this operator refers to the object passed to with : input {{ a = {x: 1, y: 2} with a b = this end b.x }} output 1 :top:","title":"4.1 The special variable this"},{"location":"language/#42-the-special-variable-empty","text":"The empty variable represents simply an empty object. It is mainly relevant to be compatible with liquid, by providing a way to compare an object with the empty object to check if it is empty or not: input {{ a = {} b = [1, 2]~}} {{a == empty}} {{b == empty}} output true false :top:","title":"4.2 The special variable empty"},{"location":"language/#5-objects","text":"Scriban supports javascript like objects {...} An object can be initialized empty : {{ myobject = {} }} An object can be initialized with some members: {{ myobject = { member1: \"yes\", member2: \"no\" } }} or use a json syntax: {{ myobject = { \"member1\": \"yes\", \"member2\": \"no\" } }} An object can be initialized with some members over multiple lines: {{ myobject = { member1: \"yes\", member2: \"no\" } }} Members of an object can be accessed: {{ myobject.member1 }} also equivalent to {{ myobject[\"member1\"] }} You can access optional members in chain via the optional member operator ?. (instead of the regular member operator: . ) ( New in 3.0 ) {{ myobject.member1?.submember1?.submember2 ?? \"nothing\" }} will return \"nothing\" as member1 doesn't contain a submember1 / submember2 . If the object is a \"pure\" scriban objects (created with a {...} or instantiated by the runtime as a ScriptObject ), you can also add members to it with a simple assignment: input {{ myobject = {} myobject.member3 = \"may be\" myobject.member3 }} output may be NOTICE By default, Properties and methods of .NET objects are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. If you want to change this behavior, you need to use a MemberRenamer delegate","title":"5 Objects"},{"location":"language/#51-the-special-property-empty","text":"Any object can respond the the property .empty? to check if it is empty or not: input {{ a = {} b = [1, 2]~}} {{a.empty?}} {{b.empty?}} output true false :top:","title":"5.1 The special property empty?"},{"location":"language/#6-arrays","text":"An array can be initialized empty : {{ myarray = [] }} An array can be initialized with some items: {{ myarray = [1, 2, 3, 4] }} An array can be initialized with some items over multiple lines: {{ myarray = [ 1, 2, 3, 4, ] }} Items of an array can be zero-based indexed: {{ myarray[0] }} If the array is a \"pure\" scriban array (created with a [...] or instantiated by the runtime as a ScriptArray ), you can also add items to it with a simple assignment that will expand automatically the array depending on the index: {{ myarray = [] myarray[0] = 1 myarray[1] = 2 myarray[2] = 3 myarray[3] = 4 }} You can also manipulate arrays with the array builtin object . Important notice While whitespace characters are mostly not relevant while parsing in scriban, there is a case where a whitespace helps to disambiguate between an array indexer and an array initializer . For instance, if a whitespace is found before a [ and the previous expression was a variable path expressions (see later), the following expression [...] will be considered as an array initializer instead of an array indexer: {{ myfunction [1] # There is a whitespace after myfunction. # It will result in a call to myfunction passing an array as an argument myvariable[1] # Without a whitespace, this is accessing # an element in the array provided by myvariable }}","title":"6 Arrays"},{"location":"language/#61-array-with-properties","text":"An array can also contains attached properties: input {{ a = [5, 6, 7] a.x = \"yes\" a.x + a[0] }} output yes5 :top:","title":"6.1 Array with properties"},{"location":"language/#62-the-special-size-property","text":"Arrays have a size property that can be used to query the number of elements in the array: input {{ a = [1, 2, 3] a.size }} output 3 :top:","title":"6.2 The special size property"},{"location":"language/#7-functions","text":"Scriban allows to define 4 kind of functions: Simple functions Anonymous functions Parametric functions ( New in 3.0 ) Inline functions ( New in 3.0 )","title":"7 Functions"},{"location":"language/#71-simple-functions","text":"The following declares a function sub that uses its first argument and subtract from it the second argument: {{func sub ret $0 - $1 end}} All argument are passed to the special variable $ that will contain the list of direct arguments and named arguments: $0 or $[0] will access the first argument $1 or $[1] will access the second argument $[-1] will access the last argument $.named will access the named argument named This function can then be used: input {{sub 5 1}} {{5 | sub 1}} output 4 4 As you can notice from the example above, when using the pipe, the result of the pipe is pushed as the first argument of the pipe receiver. Note that a function can have mixed text statements as well: {{func inc}} This is a text with the following argument {{ $0 + 1 }} {{end}} NOTE: Setting a non-local variable (e.g a = 10 ) in a simple function will be set at the global level and not at the function level. Parametric functions are solving this behavior by introducing a new variable scope inside the function that includes parameters.","title":"7.1 Simple functions"},{"location":"language/#72-anonymous-functions","text":"Anonymous functions are like simple functions but can be used in expressions (e.g as the last argument of function call) input {{ sub = do; ret $0 - $1; end; 1 | sub 3 }} output -2 They are very convenient to build custom block functions: input {{ func launch; ret $0 1 2; end launch do ret $0 + $1 end }} output 3","title":"7.2 Anonymous functions"},{"location":"language/#73-parametric-functions","text":"They are similar to simple functions but they are declared with parenthesis, while also supporting declaration of different kind of parameters (normal, optional, variable). Another difference with simple functions is that they require function calls and arguments to match the expected function parameters. A function with normal parameters: {{func sub(x,y) ret x - y end}} input {{sub 5 1}} {{5 | sub 1}} output 4 4 A function with normal parameters and optional parameters with default values: {{func sub_opt(x, y, z = 1, w = 2) ret x - y - z - w end}} input {{sub_opt 5 1}} {{5 | sub_opt 1}} output 1 1 Here we override the value of z and set it to 0 instead of default 1 : input {{sub_opt 5 1 0 }} {{5 | sub_opt 1 0}} output 2 2 A function with normal parameters and optional parameters with default values: {{func sub_variable(x, y...) ret x - (y[0] ?? 0) - (y[1] ?? 0) end}} input {{sub_variable 5 1 -1} {{5 | sub_variable 1 -1}} output 5 5 NOTE: The special variable $ is still accessible in parametric functions and represent the direct list of arguments. In the example above, $ = [5, [1, -1]]","title":"7.3 Parametric functions"},{"location":"language/#74-inline-functions","text":"For simple functions, it is convenient to define simple functions like mathematical functions: {{ sub(x,y) = x - y }} Inline functions are similar to parametric functions but they only support normal parameters. They don't support optional or variable parameters.","title":"7.4 Inline functions"},{"location":"language/#75-function-pointers","text":"Because functions are object, they can be stored into a property of an object by using the alias @ operator: {{ myobject.myinc = @inc # Use the @ alias operator to allow to # use a function without evaluating it x = 1 | myobject.myinc # x = x + 1 }} The function aliasing operator @ allows to pass a function as a parameter to another function, enabling powerful function compositions. :top:","title":"7.5 Function Pointers"},{"location":"language/#8-expressions","text":"Scriban supports conventional unary and binary expressions. :top:","title":"8 Expressions"},{"location":"language/#81-variable-path-expressions","text":"A variable path expression contains the path to a variable: A simple variable access: {{ name }} e.g resolve to the top level variable name An array access: {{ myarray[1] }} e.g resolve to the top level variable myarray and an indexer to the array A member access: {{ myobject.member1.myarray[2] }} e.g resolve to the top level variable myobject , then the property member1 this object, the property myarray and an indexer to the array returned by myarray Note that a variable path can either point to a simple variable or can result into calling a parameter less function. :top:","title":"8.1 Variable path expressions"},{"location":"language/#82-assign-expression","text":"A value can be assigned to a top level variable or to the member of an object/array: {{ name = \"foo\" }} e.g Assign the string \"foo\" the variable name {{ myobject.member1.myarray[0] = \"foo\" }} An assign expression must be a top level expression statement and cannot be used within a sub-expression. :top:","title":"8.2 Assign expression"},{"location":"language/#83-nested-expression","text":"An expression enclosed by ( and ) {{ name = ('foo' + 'bar') }} :top:","title":"8.3 Nested expression"},{"location":"language/#84-arithmetic-expressions","text":"","title":"8.4 Arithmetic expressions"},{"location":"language/#85-conditional-expressions","text":"A boolean expression produces a boolean by comparing a left and right value. Operator Description <left> == <right> Is left equal to right? <left> != <right> Is left not equal to right? <left> > <right> Is left greater than right? <left> >= <right> Is left greater or equal to right? <left> < <right> Is left less than right? <left> <= <right> Is left less or equal to right? They work with both numbers , strings and datetimes. You can combine conditional expressions with && (and operator) and || (or operator). Unlike in javascript it always returns boolean and never <left> or <right> . Operator Description <left> && <right> Is left true and right true? <left> \\|\\| <right> Is left true or right true? The conditional expression cond ? left : right allow to return left if cond is true otherwise right . ( New in 3.0 ) :top:","title":"8.5 Conditional expressions"},{"location":"language/#86-unary-expressions","text":"Operator Description ! <expression> Boolean negate an expression. e.g if !page + <expression> Arithmetic positive an expression. e.g +1.5 - <expression> Arithmetic negate an expression ^ <expression> Expand an array passed to arguments of a function call (see function call) @ <expression> Alias the result of an expression that would be evaluated if it was a function call :top:","title":"8.6 Unary expressions"},{"location":"language/#87-range-expressions","text":"They are special binary expressions that provides an iterator (used usually with the for statement) The evaluated left and right expressions must resolve to an integer at runtime. Operator Description left..right Returns an iterator between left and right with a step of 1, including right . e.g: 1..5 iterates from 1 to 5 left..<right Returns an iterator between left and right with a step of 1, excluding right . e.g: 1..<5 iterates from 1 to 4","title":"8.7 Range expressions"},{"location":"language/#88-the-null-coalescing-operator","text":"The operator left ?? right can be used to return the right value if left is null. :top:","title":"8.8 The null-coalescing operator ??"},{"location":"language/#89-function-call-expression","text":"A function can be called by passing parameters separated by a whitespace: {{ myfunction arg1 \"arg2\" (1+5) }} The pipe operator | can also be used to pipe the result of an expression to a function: {{ date.parse '2016/01/05' | date.to_string '%g' }} will output 06 Jan 2016 Notice that when a function receives the result of a pipe call (e.g date.to_string in the example above), it is passed as the first argument of the call . This is valid for both .NET custom functions as well as for Scriban integrated functions. Pipes are greedy with respect to whitespace. This allow them to be chained across multiple lines: {{- \"text\" | string.append \"END\" | string.prepend \"START\" -}} will output STARTtextEND","title":"8.9 Function call expression"},{"location":"language/#9-statements","text":"Each statement must be terminated by a code block }} or an EOL within a code block, or a semicolon to separate multiple statements on a single line within a code block. :top:","title":"9 Statements"},{"location":"language/#91-single-expression","text":"An expression statement: {{ value + 1 }} e.g Evaluates value + 1 and output the result {{ value + 1 # This is a single line expression statement followed by this comment }} :top:","title":"9.1 Single expression"},{"location":"language/#92-if-expression-else-else-if-expression","text":"The general syntax is: {{ if <expression> ... else if <expression> ... else ... end }} An if statement must be closed by an end or followed by a else or else if statement. An else or else if statement must be followed by a else , else if or closed by an end statement. An expression evaluated for a if or else if will be converted to a boolean.","title":"9.2 if &lt;expression&gt;, else, else if &lt;expression&gt;"},{"location":"language/#93-case-and-when","text":"This is the equivalent of switch statement in C#, a selection statement that chooses a single switch section to execute from a list of candidates based on a value matching. case <expression> opens a switch with an expression when <match> allows to match with the specified expression and the case expression when can also be used with multiple values separated by , or || A final else can be used to as a default handler in case nothing matched. input {{ x = 5 case x when 1, 2, 3 \"Value is 1 or 2 or 3 when 5 \"Value is 5\" else \"Value is \" + x end }} output Value is 5 :top:","title":"9.3 case and when"},{"location":"language/#93-loops","text":"","title":"9.3 Loops"},{"location":"language/#94-capture-variable-end","text":"The capture <variable> ... end statement allows to capture the template output to a variable: For example the following code: {{ capture myvariable }} This is the result of a capture {{ date.now }} {{ end }} will set myvariable = \"This is the result of a capture 06 Jan 2016\\n\" :top:","title":"9.4 capture &lt;variable&gt; ... end"},{"location":"language/#95-readonly-variable","text":"The readonly statement prevents a variable for subsequent assignments: {{ x = 1 }} {{ readonly x }} {{ x = 2 }} <- this will result in a runtime error :top:","title":"9.5 readonly &lt;variable&gt;"},{"location":"language/#96-import-variable_path","text":"The import <variable_path> statement allows to import the members of an object as variables of the current bound: {{ myobject = { member1: \"yes\" } import myobject member1 # will print the \"yes\" string to the output }} Note that readonly variables won't be override. :top:","title":"9.6 import &lt;variable_path&gt;"},{"location":"language/#97-with-variable-end","text":"The with <variable> ... end statement will open a new object context with the passed variable, all assignment will result in setting the members of the passed object. myobject = {} with myobject member1 = \"yes\" end :top:","title":"9.7 with &lt;variable&gt; ... end"},{"location":"language/#98-wrap-function-arg1argn-end","text":"Pass a block of statements to a function that will be able to evaluate it using the special variable $$ {{ func wrapped for $i in 1..<$0 $$ # This special variable evaluates the block pass # to the wrap statement end end wrap wrapped 5 $i + \" -> This is inside the wrap!\\r\\n\" end }} will output: 1 -> This is inside the wrap! 2 -> This is inside the wrap! 3 -> This is inside the wrap! 4 -> This is inside the wrap! Note that variables declared outside the with block are accessible within. :top:","title":"9.8 wrap &lt;function&gt; &lt;arg1...argn&gt; ... end"},{"location":"language/#99-include-name-arg1argn","text":"The include is not a statement but actually a function that allows to parse and render the specified template name. In order to use this function, a delegate to an template loader must be setup on the TemplateOptions.TemplateLoader property passed to the Template.Parse method. include 'myinclude.html' x = include 'myinclude.html' x + \" modified\" assuming that myinclude.html is {{ y = y + 1 ~}} This is a string with the value {{ y }} will output: This is a string with the value 1 This is a string with the value 2 modified :top:","title":"9.9 include &lt;name&gt; arg1?...argn?"},{"location":"language/#910-ret-expression","text":"The return statement is used to early exit from a top-level/include page or a function. This is a text {{~ ret ~}} This text will not appear will output: This is a text :top:","title":"9.10 ret &lt;expression&gt;?"},{"location":"liquid-support/","text":"Liquid Support Scriban supports all the core liquid syntax types, operators, tags and filters. Known issues Supported types Supported operators Supported tags Variable and properties accessors comment tag raw tag assign tag if tag unless tag case and when tags for tag tablerow tag capture tag Pipe calls Supported filters Converting liquid to scriban using liquid2scriban Known issues Note The liquid syntax has never been strictly formalized, and custom tags implementation can choose whatever syntax for their arguments. This is a known issue in liquid itself, for example: - issue 507: Custom tags: what\u2019s the preferred method of providing arguments containing quotes - issue 671: Using liquid class libraries inside Liquid::Tag - issue 560: Unified syntax for tag arguments [RFC] For example in liquid, you usually pass arguments to tags and filters like this (supported by scriban): {{ \" this is a string\" | function \"arg1\" 15 16 }} {% custom_tag \"arg1\" 15 16 %} But some liquid tag/filter implementations may in fact choose to accept different ways of passing arguments: {% avatar user = author size = 24 %} There is in fact multiple versions of the liquid language, supporting different syntaxes for tags, which are completely arbitrary and not unified. As a consequence, the liquid parser implemented in Scriban cannot parse any custom liquid tags/filters that are using custom arguments parsing but only regular arguments (strings, numbers, variables, variable properties) separated by spaces. :top: Supported types Liquid types are translated to the same types in scriban: string number boolean The nil value (which can't be expressed in liquid) is equivalent to the expression null in scriban. array are also supported, except that scriban allows to create arrays directly from the language unlike liquid In addition to this, scriban supports the creation of an object :top: Supported operators Liquid supports only conditional expressions and they directly translate to conditionnal expressions in scriban. In addition to this, scriban supports: binary operators unary operators range 1..x expressions The null coalescing operator ?? :top: Supported tags In the following sections, you will find a list of the supported liquid tags and how scriban translates a liquid template into a scriban template. NOTE: All the following examples are using the feature Ast to text that allowed to translate liquid code into scriban code automatically :top: Variable and properties accessors Liquid Scriban {% assign variable = 1 %} {{ variable = 1 }} {{ variable }} {{ variable }} {{ my-handle }} {{ this[\"my-handle\" }} {{ page.title }} {{ page.title }} {% assign for = 5 %} {{ (for) = 5 }} (for keyword needs parenthesis in scriban) {{ for }} {{ (for) }} {{ products[0].title }} {{ products[0].title }} {{ product.empty? }} {{ product.empty? }} :top: comment tag Liquid comment / endcomment tags translate to a code block {{ ... }} embracing a multiline comments ## liquid This is plain {% comment %} This is comment {% with ## some tag %} and comment {% endcomment %} scriban This is plain {{## This is comment {% with \\#\\# some tag %\\} and comment ##}} :top: raw tag Liquid raw tag block translate to an escape block liquid This is plain {% raw %} This is raw {% with some tag %} and raw {% endraw %} scriban This is plain {%{This is raw {% with some tag %} and raw}%} :top: assign tag Liquid assign tag translates to a simple assignment expression liquid {% assign variable = 1 %} {{ variable }} scriban {{ variable = 1 }} {{ variable }} :top: if tag Liquid if <expression> / endif tags translate to a if <expression> / end liquid {% assign variable = 1 %} {% if variable == 1 %} This is a variable with 1 {% endif %} scriban {{ variable = 1 }} {{ if variable == 1 }} This is a variable with 1 {{ end }} :top: unless tag Liquid unless <expression> / endunless tags translate to a if <expression> / end with a reversed nested !(expression) liquid {% assign variable = 1 %} {% unless variable == 1 %} This is not a variable with 1 {% endunless %} scriban {{ variable = 1 }} {{ if!( variable == 1 )}} This is not a variable with 1 {{ end }} :top: case and when tags Liquid case <variable> / when <expression> / endcase tags translate to a case <expression> / when <expression> / end liquid {% - assign variable = 5 - %} {% - case variable - %} {% - when 6 - %} Yo 6 {% - when 7 - %} Yo 7 {% - when 5 - %} Yo 5 {% endcase - %} scriban {{ variable = 5 -}} {{ case variable -}} {{ when 6 -}} Yo 6 {{- when 7 -}} Yo 7 {{- when 5 -}} Yo 5 {{ end }} :top: for tag Liquid for <variable> in <expression> / endfor tags translate to the same for / end liquid {% - for variable in ( 1 .. 5 ) - %} This is variable {{ variable }} {% endfor - %} scriban {{ for variable in (1..5) -}} This is variable {{variable}} {{ end }} NOTE: Scriban supports all tags arguments: limit , offset , reversed :top: tablerow tag Liquid tablerow <variable> in <expression> / endtablerow tags translate to the same tablerow / end liquid {% - tablerow variable in ( 1 .. 5 ) - %} This is variable {{ variable }} {% endtablerow - %} scriban {{ tablerow variable in (1..5) -}} This is variable {{variable}} {{ end }} NOTE: Scriban supports all tags arguments for tablerow : cols , limit , offset , reversed :top: capture tag Liquid capture <variable> / endcapture tags translate to a capture <expression> / end liquid {% - capture variable - %} This is a capture {% - endcapture - %} {{ variable }} scriban {{ capture variable -}} This is a capture {{- end -}} {{ variable }} :top: Pipe calls Liquid pipe call translates to the same pipe call liquid {% assign test = \"abcdef\" %} {{ test | truncate : 5 }} scriban {{ test = \"abcdef\" }} {{ test | string.truncate 5 }} As you can notice, Scriban will translate a call to a liquid tag to the corresponding scriban tag. But scriban also provides supports for direct tags calls using the LiquidTemplateContext . See liquid support in runtime :top: Supported filters By default, all liquid filters are translated to scriban builtin functions (through objects like string or array ) The translation is performed by the TryLiquidToScriban function at parsing time. This translation can be disabled by setting the ParserOptions.LiquidFunctionsToScriban to false :top: Converting liquid to scriban using liquid2scriban If you compile this repository, you will find a tool liquid2scriban that allows to convert a liquid script to scriban. The liquid2scriban has one option that allows to parse Jekyll liquid templates that are passing to the include directive raw strings without quotes (e.g {% include /this/is/partial.html %} ) In that case, you can pass the option --relaxed-include to liquid2scriban, to allow the convertor to recognize this parameter as an implicit string instead.","title":"Liquid Support"},{"location":"liquid-support/#liquid-support","text":"Scriban supports all the core liquid syntax types, operators, tags and filters. Known issues Supported types Supported operators Supported tags Variable and properties accessors comment tag raw tag assign tag if tag unless tag case and when tags for tag tablerow tag capture tag Pipe calls Supported filters Converting liquid to scriban using liquid2scriban","title":"Liquid Support"},{"location":"liquid-support/#known-issues","text":"Note The liquid syntax has never been strictly formalized, and custom tags implementation can choose whatever syntax for their arguments. This is a known issue in liquid itself, for example: - issue 507: Custom tags: what\u2019s the preferred method of providing arguments containing quotes - issue 671: Using liquid class libraries inside Liquid::Tag - issue 560: Unified syntax for tag arguments [RFC] For example in liquid, you usually pass arguments to tags and filters like this (supported by scriban): {{ \" this is a string\" | function \"arg1\" 15 16 }} {% custom_tag \"arg1\" 15 16 %} But some liquid tag/filter implementations may in fact choose to accept different ways of passing arguments: {% avatar user = author size = 24 %} There is in fact multiple versions of the liquid language, supporting different syntaxes for tags, which are completely arbitrary and not unified. As a consequence, the liquid parser implemented in Scriban cannot parse any custom liquid tags/filters that are using custom arguments parsing but only regular arguments (strings, numbers, variables, variable properties) separated by spaces. :top:","title":"Known issues"},{"location":"liquid-support/#supported-types","text":"Liquid types are translated to the same types in scriban: string number boolean The nil value (which can't be expressed in liquid) is equivalent to the expression null in scriban. array are also supported, except that scriban allows to create arrays directly from the language unlike liquid In addition to this, scriban supports the creation of an object :top:","title":"Supported types"},{"location":"liquid-support/#supported-operators","text":"Liquid supports only conditional expressions and they directly translate to conditionnal expressions in scriban. In addition to this, scriban supports: binary operators unary operators range 1..x expressions The null coalescing operator ?? :top:","title":"Supported operators"},{"location":"liquid-support/#supported-tags","text":"In the following sections, you will find a list of the supported liquid tags and how scriban translates a liquid template into a scriban template. NOTE: All the following examples are using the feature Ast to text that allowed to translate liquid code into scriban code automatically :top:","title":"Supported tags"},{"location":"liquid-support/#variable-and-properties-accessors","text":"Liquid Scriban {% assign variable = 1 %} {{ variable = 1 }} {{ variable }} {{ variable }} {{ my-handle }} {{ this[\"my-handle\" }} {{ page.title }} {{ page.title }} {% assign for = 5 %} {{ (for) = 5 }} (for keyword needs parenthesis in scriban) {{ for }} {{ (for) }} {{ products[0].title }} {{ products[0].title }} {{ product.empty? }} {{ product.empty? }} :top:","title":"Variable and properties accessors"},{"location":"liquid-support/#comment-tag","text":"Liquid comment / endcomment tags translate to a code block {{ ... }} embracing a multiline comments ## liquid This is plain {% comment %} This is comment {% with ## some tag %} and comment {% endcomment %} scriban This is plain {{## This is comment {% with \\#\\# some tag %\\} and comment ##}} :top:","title":"comment tag"},{"location":"liquid-support/#raw-tag","text":"Liquid raw tag block translate to an escape block liquid This is plain {% raw %} This is raw {% with some tag %} and raw {% endraw %} scriban This is plain {%{This is raw {% with some tag %} and raw}%} :top:","title":"raw tag"},{"location":"liquid-support/#assign-tag","text":"Liquid assign tag translates to a simple assignment expression liquid {% assign variable = 1 %} {{ variable }} scriban {{ variable = 1 }} {{ variable }} :top:","title":"assign tag"},{"location":"liquid-support/#if-tag","text":"Liquid if <expression> / endif tags translate to a if <expression> / end liquid {% assign variable = 1 %} {% if variable == 1 %} This is a variable with 1 {% endif %} scriban {{ variable = 1 }} {{ if variable == 1 }} This is a variable with 1 {{ end }} :top:","title":"if tag"},{"location":"liquid-support/#unless-tag","text":"Liquid unless <expression> / endunless tags translate to a if <expression> / end with a reversed nested !(expression) liquid {% assign variable = 1 %} {% unless variable == 1 %} This is not a variable with 1 {% endunless %} scriban {{ variable = 1 }} {{ if!( variable == 1 )}} This is not a variable with 1 {{ end }} :top:","title":"unless tag"},{"location":"liquid-support/#case-and-when-tags","text":"Liquid case <variable> / when <expression> / endcase tags translate to a case <expression> / when <expression> / end liquid {% - assign variable = 5 - %} {% - case variable - %} {% - when 6 - %} Yo 6 {% - when 7 - %} Yo 7 {% - when 5 - %} Yo 5 {% endcase - %} scriban {{ variable = 5 -}} {{ case variable -}} {{ when 6 -}} Yo 6 {{- when 7 -}} Yo 7 {{- when 5 -}} Yo 5 {{ end }} :top:","title":"case and when tags"},{"location":"liquid-support/#for-tag","text":"Liquid for <variable> in <expression> / endfor tags translate to the same for / end liquid {% - for variable in ( 1 .. 5 ) - %} This is variable {{ variable }} {% endfor - %} scriban {{ for variable in (1..5) -}} This is variable {{variable}} {{ end }} NOTE: Scriban supports all tags arguments: limit , offset , reversed :top:","title":"for tag"},{"location":"liquid-support/#tablerow-tag","text":"Liquid tablerow <variable> in <expression> / endtablerow tags translate to the same tablerow / end liquid {% - tablerow variable in ( 1 .. 5 ) - %} This is variable {{ variable }} {% endtablerow - %} scriban {{ tablerow variable in (1..5) -}} This is variable {{variable}} {{ end }} NOTE: Scriban supports all tags arguments for tablerow : cols , limit , offset , reversed :top:","title":"tablerow tag"},{"location":"liquid-support/#capture-tag","text":"Liquid capture <variable> / endcapture tags translate to a capture <expression> / end liquid {% - capture variable - %} This is a capture {% - endcapture - %} {{ variable }} scriban {{ capture variable -}} This is a capture {{- end -}} {{ variable }} :top:","title":"capture tag"},{"location":"liquid-support/#pipe-calls","text":"Liquid pipe call translates to the same pipe call liquid {% assign test = \"abcdef\" %} {{ test | truncate : 5 }} scriban {{ test = \"abcdef\" }} {{ test | string.truncate 5 }} As you can notice, Scriban will translate a call to a liquid tag to the corresponding scriban tag. But scriban also provides supports for direct tags calls using the LiquidTemplateContext . See liquid support in runtime :top:","title":"Pipe calls"},{"location":"liquid-support/#supported-filters","text":"By default, all liquid filters are translated to scriban builtin functions (through objects like string or array ) The translation is performed by the TryLiquidToScriban function at parsing time. This translation can be disabled by setting the ParserOptions.LiquidFunctionsToScriban to false :top:","title":"Supported filters"},{"location":"liquid-support/#converting-liquid-to-scriban-using-liquid2scriban","text":"If you compile this repository, you will find a tool liquid2scriban that allows to convert a liquid script to scriban. The liquid2scriban has one option that allows to parse Jekyll liquid templates that are passing to the include directive raw strings without quotes (e.g {% include /this/is/partial.html %} ) In that case, you can pass the option --relaxed-include to liquid2scriban, to allow the convertor to recognize this parameter as an implicit string instead.","title":"Converting liquid to scriban using liquid2scriban"},{"location":"runtime/","text":"Runtime This document describes the runtime API to manipulate scriban text templating. Scriban provides a safe runtime , meaning it doesn't expose any .NET objects that haven't been made explicitly available to a Template. The runtime is composed of two main parts: The parsing/compiler infrastructure that is responsible for parsing a text template and build a runtime representation of it (we will call this an Abstract Syntax Tree ) The rendering/evaluation infrastructure that is responsible to render a compiled template to a string. We will see also that we can evaluate expressions without rendering. The scriban runtime was designed to provide an easy, powerful and extensible infrastructure. For example, we are making sure that nothing in the runtime is using a static, so that you can correctly override all the behaviors of the runtime. Parsing a template Parsing modes Parsing languages Liquid support Rendering a template Overview The TemplateContext execution model The ScriptObject Accessing as regular dictionary objects Imports a .NET delegate Imports functions from a .NET class Automatic functions import from ScriptObject Function arguments, optional and params Accessing nested ScriptObject Imports a ScriptObject into another ScriptObject Imports a .NET object instance Accessing a .NET object read-only properties The builtin functions The stack of ScriptObject The with statement with the stack Advanced usages Member renamer Member filter Include and ITemplateLoader The Lexer and Parser Abstract Syntax Tree AST to Text Extending TemplateContext ScriptObject advanced usages Advanced custom functions Hyper custom functions IScriptCustomFunction Evaluating an expression Changing the Culture Safe Runtime :top: Parsing a template The Scriban.Template class is a main entry point to easily parse a template and renders it. The action of parsing consist of compiling the template to a faster runtime representation, suitable later for rendering the template. This class is mostly a user friendly frontend to the underlying classes used to parse a template. See The Lexer and Parser section for advanded usages. The Template.Parse method is a convenient method to parse a template from a string and returns the compiled Template: var inputTemplateAsText = \"This is a {{ name }} template\" ; // Parse the template var template = Template . Parse ( inputTemplateAsText ); // Check for any errors if ( template . HasErrors ) { foreach ( var error in template . Messages ) { Console . WriteLine ( error ); } return ; // or throw...etc. } The returned Template object has the following relevant properties: ScriptPage Page {get;} that contains the compiled template to a root Abstract Syntax Tree (AST). From this object you can navigate through all the statements parsed from the template if necessary. See the section about the Abstract Syntax Tree bool HasErrors {get;} to check if the parsed template has any errors. In that case, the ScriptPage Page property is null . List<LogMessage> Messages {get;} contains the list of warning and error messages while parsing the template. If you are using the Template.Parse method, it is important to verify HasErrors is false , otherwise you will get a null ScriptPage object from the Template.Page property. The parse method can take an additional argument sourceFilePath used when reporting syntax errors, typically used to associate a template file read from the disk or an editor and you want to report the exact error to the user. // Parse the template var template = Template . Parse ( File . ReadAllText ( filePath ), filePath ); Note that the sourceFilePath is not used for accessing the disk (it could be a logical path to a zip file, or the name of tab opened in an editor...etc.). It is only a logical name that is used when reporting errors, but also you will see with the include directive and the setup of the Template Loader that this value can be used to perform an include operation in the relative context to the template path being processed. :top: Parsing modes By default, when parsing a template, the template is expected to have mixed content of text and scriban code blocks enclosed by {{ and }} . But you can modify the way a template is parsed by passing a LexerOptions to the Template.Parse method. The parsing mode is defined by the LexerOptions.Mode property which is ScriptMode.Default by default (i.e. mixed text and code). But you can also parse a template that contains directly scripting code (without enclosing {{ }} ), in that case, you can use the ScriptMode.ScriptOnly mode. For example illustrate how to use the ScriptOnly mode: // Create a template in ScriptOnly mode var lexerOptions = new LexerOptions () { Mode = ScriptMode . ScriptOnly }; // Notice that code is not enclosed by `{{` and `}}` var template = Template . Parse ( \"y = x + 1; y;\" , lexerOptions : lexerOptions ); // Renders it with the specified parameter var result = template . Evaluate ( new { x = 10 }); // Prints 11 Console . WriteLine ( result ); :top: Parsing languages Scriban provides 3 languages through the ScriptLang enum: ScriptLang.Default : which is the default Scriban Language ScriptLang.Liquid : which is used to parse the language with liquid syntax. ScriptLang.Scientific : which is similar to the default, but handles expression slight differently: Arguments separated by a space will convert to a multiplication: 2 x will be evaluated as 2 * x Except if a function is taking one argument, and in that case it resolves to a function call cos x resolves to cos(x) Otherwise function calls need to use explicit parenthesis myfunction(1,2,3) The language is defined by the LexerOptions.Lang property which. For example illustrate how to use the the ScriptLang.Scientific and the ScriptOnly mode: // Create a template in ScriptOnly mode var lexerOptions = new LexerOptions () { Lang = ScriptLang . Scientific , Mode = ScriptMode . ScriptOnly }; // Notice that code is not enclosed by `{{` and `}}` var template = Template . Parse ( \"y = x + 1; 2y;\" , lexerOptions : lexerOptions ); // Renders it with the specified parameter var result = template . Evaluate ( new { x = 10 }); // Prints 22 Console . WriteLine ( result ); :top: Liquid support Scriban supports a Lexer and Parser that can understand a Liquid template instead, while still translating it to a Scriban Runtime AST. You can easily parse an existing liquid template using the Template.ParseLiquid method: // An Liquid var inputTemplateAsText = \"This is a {{ name }} template\" ; // Parse the template var template = Template . ParseLiquid ( inputTemplateAsText ); // Renders the template with the variable `name` exposed to the template var result = template . Render ( new { name = \"Hello World\" }); // Prints the result: \"This is a Hello World template\" Console . WriteLine ( result ); Also, in terms of runtime, Liquid builtin functions are supported. They are created with the LiquidTemplateContext which inherits from the TemplateContext . :top: Rendering a template Overview In order to render a template, you need pass a context for the variables, objects, functions that will be accessed by the template. In the following examples, we have a variable name that is used by the template: var inputTemplateAsText = \"This is a {{ name }} template\" ; // Parse the template var template = Template . Parse ( inputTemplateAsText ); // Renders the template with the variable `name` exposed to the template var result = template . Render ( new { name = \"Hello World\" }); // Prints the result: \"This is a Hello World template\" Console . WriteLine ( result ); As we can see, we are passing an anonymous objects that has this field/property name and by calling the Render method, the template is executed with this data model context. While passing an anonymous object is nice for a hello world example, it is not always enough for more advanced data model scenarios. In this case, you want to use more directly the TemplateContext (used by the method Template.Render(object) ) and a ScriptObject which are both at the core of scriban rendering architecture to provide more powerful constructions & hooks of the data model exposed (variables but also functions...etc.). :top: The TemplateContext execution model The TemplateContext provides: an execution context when evaluating a template. The same instance can be used with many different templates, depending on your requirements. A stack of ScriptObject that provides the actual variables/functions accessible to the template, accessible through Template.PushGlobal(scriptObj) and Template.PopGlobal() . Why a stack and how to use this stack is described below. The text output when evaluating a template, which is accessible through the Template.Output property as a StringBuilder but because you can have nested rendering happening, it is possible to use Template.PushOutput() and Template.PopOutput() to redirect temporarily the output to a new output. This functionality is typically used by the capture statement . Caching of templates previously loaded by an include directive (see include and ITemplateLoader section ) Various possible overrides to allow fine grained extensibility (evaluation of an expression, conversion to a string, enter/exit/step into a loop...etc.) Note that a TemplateContext is not thread safe, so it is recommended to have one TemplateContext per thread. :top: The ScriptObject The ScriptObject is a special implementation of a Dictionary<string, object> that runtime properties and functions accessible to a template: Accessing as regular dictionary objects A ScriptObject is mainly an extended version of a IDictionary<string, object> : var scriptObject1 = new ScriptObject (); scriptObject1 . Add ( \"var1\" , \"Variable 1\" ); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is var1: `{{var1}}`\" ); var result = template . Render ( context ); // Prints: This is var1: `Variable 1` Console . WriteLine ( result ); Note that any IDictionary<string, object> put as a property will be accessible as well. Imports a .NET delegate Via ScriptObject.Import(member, Delegate) . Here we import a Func<string> : var scriptObject1 = new ScriptObject (); // Declare a function `myfunc` returning the string `Yes` scriptObject1 . Import ( \"myfunc\" , new Func < string >(() => \"Yes\" )); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is myfunc: `{{myfunc}}`\" ); var result = template . Render ( context ); // Prints: This is myfunc: `Yes` Console . WriteLine ( result ); Imports functions from a .NET class You can easily import static methods declared in a .NET class via ScriptObject.Import(typeof(MyFunctions)) Let's define a class with a static function Hello : public static class MyFunctions { public static string Hello () { return \"hello from method!\" ; } } This function can be imported into a ScriptObject: var scriptObject1 = new ScriptObject (); scriptObject1 . Import ( typeof ( MyFunctions )); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is MyFunctions.Hello: `{{hello}}`\" ); var result = template . Render ( context ); // Prints This is MyFunctions.Hello: `hello from method!` Console . WriteLine ( result ); Notice that when using a function with pipe calls like {{description | string.strip }} , the last argument passed to the string.strip function is the result of the previous pipe. That's a reason why you will notice in all builtin functions in scriban that they usually take the most relevant parameter as a last parameter instead of the first parameter, to allow proper support for pipe calls. NOTICE By default, Properties and static methods of .NET objects are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. If you want to change this behavior, you need to use a MemberRenamer delegate Automatic functions import from ScriptObject When inheriting from a ScriptObject , the inherited object will automatically import all public static methods and properties from the class: // We simply inherit from ScriptObject // All functions defined in the object will be imported public class MyCustomFunctions : ScriptObject { public static string Hello () { return \"hello from method!\" ; } [ScriptMemberIgnore] // This method won't be imported public static void NotImported () { // ... } } Then using directly this custom ScriptObject as a regular object: var scriptObject1 = new MyCustomFunctions (); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is MyFunctions.Hello: `{{hello}}`\" ); var result = template . Render ( context ); // Prints This is MyFunctions.Hello: `hello from method!` Console . WriteLine ( result ); Notice that if you want to ignore a member when importing a .NET object or .NET class, you can use the attribute ScriptMemberIgnore NOTE: Because Scriban doesn't support Function overloading, it is required that functions imported from a type must have different names. NOTICE By default, Properties and methods of .NET objects are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. If you want to change this behavior, you need to use a MemberRenamer delegate Function arguments, optional and params Scriban runtime supports regular function arguments, optional arguments (with a default value) and params XXX[] array arguments: // We simply inherit from ScriptObject // All functions defined in the object will be imported public class MyCustomFunctions : ScriptObject { // A function an optional argument public static string HelloOpt ( string text , string option = null ) { return $ \"hello {text} with option:{option}\" ; } // A function with params public static string HelloArgs ( params object [] args ) { return $ \"hello {(string.Join(\" , \", args))}\" ; } } Using the function above from a script could be like this: input {{ hello_opt \"test\" }} {{ hello_opt \"test\" \"my_option\" }} {{ hello_opt \"test\" option: \"my_option\" }} {{ hello_opt text: \"test\" }} {{ hello_args \"this\" \"is\" \"a\" \"test\"}} {{ hello_args \"this\" \"is\" args: \"a\" args: \"test\"}} output hello test with option: hello test with option:my_option hello test with option:my_option hello test with option: hello this,is,a,test hello this,is,a,test Notice that we can have a mix of regular and named arguments, assuming that named arguments are always coming last when calling a function. Also, we can see that named arguments are also working with params arguments. If a regular argument (not optional) is missing, the runtime will complain about the missing argument giving precise source location of the error. Accessing nested ScriptObject A nested ScriptObject can be accessed indirectly through another ScriptObject : var scriptObject1 = new ScriptObject (); var nestedObject = new ScriptObject (); nestedObject [ \"x\" ] = 5 ; scriptObject1 . Add ( \"subObject\" , nestedObject ); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is Hello: `{{subObject.x}}`\" ); template . Render ( context ); Imports a ScriptObject into another ScriptObject The properties/functions of a ScriptObject can be imported into another instance. var scriptObject1 = new ScriptObject (); scriptObject1 . Add ( \"var1\" , \"Variable 1\" ); var scriptObject2 = new ScriptObject (); scriptObject2 . Add ( \"var2\" , \"Variable 2\" ); // After this command, scriptObject2 contains var1 and var2 // But modifying var2 on scriptObject2 will not modify var2 on scriptObject1! scriptObject2 . Import ( scriptObject1 ); Imports a .NET object instance You can easily import a .NET object instance (including its public properties and static methods) into a ScriptObject NOTE that when importing into a ScriptObject, the import actually copies the property values into the ScriptObject . The original .NET object is no longer used. Importing a .NET object instance is thus different from accessing a .NET object instance through a ScriptObject. Let's define a standard .NET object: public class MyObject { public MyObject () { Hello = \"hello from property!\" ; } public string Hello { get ; set ; } } and import the properties/functions of this object into a ScriptObject, via ScriptObject.Import(object) : var scriptObject1 = new ScriptObject (); scriptObject1 . Import ( new MyObject ()); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is Hello: `{{hello}}`\" ); var result = template . Render ( context ); // Prints This is MyFunctions.Hello: `hello from method!` Console . WriteLine ( result ); Also any objects inheriting from IDictionary<TKey, TValue> or IDictionary will be also accessible automatically. Typically, you can usually access directly any generic JSON objects that was parsed by a JSON library. NOTICE By default, Properties and static methods of .NET objects are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. If you want to change this behavior, you need to use a MemberRenamer delegate Accessing a .NET object This is an important feature of scriban. Every .NET objects made accessible through a ScriptObject is directly accessible without importing it. It means that Scriban will directly work on the .NET object instance instead of a copy (e.g when we do a ScriptObject.Import instead) Note that for security reason, only the properties of .NET objects accessed through another ScriptObject are made accessible from a Template. Methods and static methods are not automatically imported. For example, if we re-use the previous MyObject directly as a variable in a ScriptObject : var scriptObject1 = new ScriptObject (); // Notice: MyObject is not imported but accessible through // the variable myobject scriptObject1 [ \"myobject\" ] = new MyObject (); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is Hello: `{{myobject.hello}}`\" ); var result = template . Render ( context ); // Prints This is MyFunctions.Hello: `hello from method!` Console . WriteLine ( result ); NOTICE By default, Properties and static methods of .NET objects are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. If you want to change this behavior, you need to use a MemberRenamer delegate read-only properties Runtime equivalent of the language readonly <var> statement, you can easily define a variable of a ScriptObject as read-only var scriptObject1 = new ScriptObject (); // The variable `var1` is immutable scriptObject1 . SetValue ( \"var1\" , \"My immutable variable\" , true ); // Or or an existing property/function member: scriptObject1 . SetReadonly ( \"var1\" , true ); The builtin functions For example, all builtin functions object of Scriban are imported easily by inheriting from a ScriptObject : The BuilinsFunctions object defined here and listed here is directly used as the bottom level stack ScriptObject as explained below. Each sub function objects (e.g array , string ) are also regular ScriptObject . For example, the string builtin functions The current builtin ScriptObject defined for a TemplateContext is accessible through the TemplateContext.BuiltinObject property. See section about ScriptObject advanced usages also for more specific usages. :top: The stack of ScriptObject A TemplateContext maintains a stack of ScriptObject that defines the state of the variables accessible from the current template. When evaluating a template and resolving a variable , the TemplateContext will lookup to the stack of ScriptObject for the specified variable. From the top of the stack (the latest PushGlobal ) to the bottom of the stack, when a variable is accessed from a template, the closest variable in the stack will be returned. By default, the TemplateContext is initialized with a builtin ScriptObject which contains all the default builtin functions provided by scriban. You can pass your own builtin object if you want when creating a new TemplateContext . Then, each time you do a TemplateContext.PushGlobal(scriptObject) , you push a new ScriptObject accessible for resolving variable Let's look at the following example: // Creates scriptObject1 var scriptObject1 = new ScriptObject (); scriptObject1 . Add ( \"var1\" , \"Variable 1\" ); scriptObject1 . Add ( \"var2\" , \"Variable 2\" ); // Creates scriptObject2 var scriptObject2 = new ScriptObject (); // overrides the variable \"var2\" scriptObject2 . Add ( \"var2\" , \"Variable 2 - from ScriptObject 2\" ); // Creates a template with (builtins) + scriptObject1 + scriptObject2 variables var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); context . PushGlobal ( scriptObject2 ); var template = Template . Parse ( \"This is var1: `{{var1}}` and var2: `{{var2}}\" ); var result = template . Render ( context ); // Prints: \"This is var1: `Variable 1` and var2: `Variable 2 - from ScriptObject 2\" Console . WriteLine ( result ); The TemplateContext stack is setup like this: scriptObject2 => scriptObject1 => builtins As you can see the variable var1 will be resolved from scriptObject1 but the variable var2 will be resolved from scriptObject2 as there is an override here. NOTE If a variable is not found, the runtime will not throw an error but will return null instead. It allows to check for a variable existence if !page for example. In case you want your script to throw an exception if a variable was not found, you can specify TemplateContext.StrictVariables = true to enforce checks. See the safe runtime section for more details. When writing to a variable, only the ScriptObject at the top of the TemplateContext will be used. This top object is accessible through TemplateContext.CurrentGlobal property. It the previous example, if we had something like this in a template: var template2 = Template . Parse ( \"This is var1: `{{var1}}` and var2: `{{var2}}`{{var2 = 5}} and new var2: `{{var2}}\" ); var result = template2 . Render ( context ); // Prints: \"This is var1: `Variable 1` and var2: `Variable 2 - from ScriptObject 2 and new var2: `5`\" Console . WriteLine ( result ); The scriptObject2 object will now contain the var2 = 5 The stack provides a way to segregate variables between their usages or read-only/accessibility/mutability requirements. Typically, the builtins ScriptObject is a normal ScriptObject that contains all the builtins objects but you cannot modify directly the builtins object. But you could modify the sub-builtins objects. For example, the following code adds a new property myprop to the builtin object string : {{ string.myprop = \"Yoyo\" }} Because scriban allows you to define new functions directly into the language and also allow to store a function pointer by using the alias @ operator, you can basically extend an existing object with both properties and functions. The with statement with the stack When using the with statement with a script object, it is relying on this concept of stack: with <scriptobject> is equivalent of calling TemplateContext.PushGlobal(scriptObject) Assigning a variable enclosed by a with statement will set variable on the target object of the with statement. Ending a with is equivalent of calling context.PopGlobal() var scriptObject1 = new ScriptObject (); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( @\" Create a variable {{ myvar = {} with myvar # Equivalent of calling context.PushGlobal(myvar) x = 5 # Equivalent to set myvar.x = 5 y = 6 end # Equivalent of calling context.PopGlobal() }}\" ); template . Render ( context ); // Contains 5 Console . WriteLine ((( ScriptObject ) scriptObject1 [ \"myvar\" ])[ \"x\" ]); :top: Advanced usages Member renamer By default, .NET objects accessed through a ScriptObject are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. A renamer is simply a delegate that takes an input MemberInfo and return a new member name: namespace Scriban.Runtime { public delegate string MemberRenamerDelegate ( MemberInfo member ); } The StandardMemberRenamer is used to convert string camel/pascal case strings to \"ruby\" like strings. If you want to import a .NET object without changing the cases, you can use the simple nop member renamer member => member.Name . Note that renaming can be changed at two levels: When importing a .NET object into a ScriptObject by passing a renamer delegate, before passing an object to a TemplateContext : var scriptObject1 = new ScriptObject (); // Here the renamer will just return a same member name as the original // hence importing .NET member name as-is scriptObject1 . Import ( new MyObject (), renamer : member => member . Name ); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is Hello: `{{Hello}}`\" ); var result = template . Render ( context ); // Prints This is MyFunctions.Hello: `hello from method!` Console . WriteLine ( result ); - By setting the default member renamer on the TemplateContext // Setup a default renamer at the `TemplateContext` level var context = new TemplateContext { MemberRenamer = member => member . Name }; It is important to setup this on the TemplateContext for any .NET objects that might be accessed indirectly through another ScriptObject so that when a .NET object is exposed, it is exposed with the correct naming convention. The method Template.Render(object, renamer) takes also a member renamer, imports the object model with the renamer and setup correctly the renamer on the underlying TemplateContext . So you can rewrite the previous example with the shorter version: var template = Template . Parse ( \"This is Hello: `{{Hello}}`\" ); template . Render ( new MyObject (), member => member . Name ); :top: Member filter Similar to the member renamer, by default, .NET objects accessed through a ScriptObject are automatically exposing all public instance fields and properties of .NET objects. A filter is simply a delegate that takes an input MemberInfo and return a boolean to indicate whether to expose the member ( true ) or discard the member ( false ) namespace Scriban.Runtime { /// <summary> /// Allows to filter a member while importing a .NET object into a ScriptObject /// or while exposing a .NET instance through a ScriptObject, /// by returning <c>true</c> to keep the member; or false to discard it. /// </summary> /// <param name=\"member\">A member info</param> /// <returns><c>true</c> to keep the member; otherwise <c>false</c> to remove the member</returns> public delegate bool MemberFilterDelegate ( MemberInfo member ); } You can use a MemberFilter when importing a an instance: var scriptObject1 = new ScriptObject (); // Imports only properties that contains the word \"Yo\" scriptObject1 . Import ( new MyObject (), filter : member => member is PropertyInfo && member . Name . Contains ( \"Yo\" )); - By setting the default member filter on the TemplateContext , so that .NET objects automatically exposed via a ScriptObject will follow the global filtering rules defined on the context: // Setup a default filter at the `TemplateContext` level var context = new TemplateContext { MemberFilter = member => member is PropertyInfo && member . Name . Contains ( \"Yo\" ) }; As for the member renamer, it is important to setup this on the TemplateContext for any .NET objects that might be accessed indirectly through another ScriptObject so that when a .NET object is exposed, it is exposed with the same filtering convention :top: Include and ITemplateLoader The include directives requires that a template loader is setup on the TemplateContext.TemplateLoader property A template loader is responsible for providing the text template from an include directive. The interface of a ITemplateLoader is defined like this: /// <summary> /// Interface used for loading a template. /// </summary> public interface ITemplateLoader { /// <summary> /// Gets an absolute path for the specified include template name. Note that it is not necessarely a path on a disk, /// but an absolute path that can be used as a dictionary key for caching) /// </summary> /// <param name=\"context\">The current context called from</param> /// <param name=\"callerSpan\">The current span called from</param> /// <param name=\"templateName\">The name of the template to load</param> /// <returns>An absolute path or unique key for the specified template name</returns> string GetPath ( TemplateContext context , SourceSpan callerSpan , string templateName ); /// <summary> /// Loads a template using the specified template path/key. /// </summary> /// <param name=\"context\">The current context called from</param> /// <param name=\"callerSpan\">The current span called from</param> /// <param name=\"templatePath\">The path/key previously returned by <see cref=\"GetPath\"/></param> /// <returns>The content string loaded from the specified template path/key</returns> string Load ( TemplateContext context , SourceSpan callerSpan , string templatePath ); } In order to use the include directive, the template loader should provide: The GetPath method translates a templateName (the argument passed to the include <templateName> directive) to a logical/phyisical path that the ITemplateLoader.Load method will understand. The Load method to actually load the the text template code from the specified templatePath (previously returned by GetPath method) The 2 step methods, GetPath and then Load allows to cache intermediate results. If a template loader returns the same template path for a template name any existing cached templates will be returned instead. Cached templates are stored in the TemplateContext.CachedTemplates property. A typical implementation of ITemplateLoader could read data from the disk: ``` C # /// <summary> /// A very simple ITemplateLoader loading directly from the disk, without any checks...etc. /// </summary> public class MyIncludeFromDisk : ITemplateLoader { string GetPath ( TemplateContext context , SourceSpan callerSpan , string templateName ) { return Path . Combine ( Environment . CurrentDirectory , templateName ); } string Load ( TemplateContext context , SourceSpan callerSpan , string templatePath ) { // Template path was produced by the `GetPath` method above in case the Template has // not been loaded yet return File . ReadAllText ( templatePath ); } } :top: The Lexer and Parser The Lexer class is responsible for extracting Tokens from a text template. The Parser class is responsible for creating ScriptNode AST from input tokens (extracted from the Lexer ) The lexer has a few LexerOptions to control the way the lexer is behaving, as described with the parsing modes The parser has a ParserOptions only used for securing nested statements/blocks to avoid any stack overflow exceptions while parsing a document. :top: Abstract Syntax Tree The base object used by the syntax for all scriban elements is the class Scriban.Syntax.ScriptNode : /// <summary> /// Base class for the abstract syntax tree of a scriban program. /// </summary> public abstract class ScriptNode { /// <summary> /// The source span of this node. /// </summary> public SourceSpan Span ; /// <summary> /// Evaluates this instance with the specified context. /// </summary> /// <param name=\"context\">The template context.</param> public abstract object Evaluate ( TemplateContext context ); } As you can see, each ScriptNode contains a method to evaluate it against a TemplateContext . You can go through the all the Syntax classes in the codebase and you will see that it is very easy to create a new SyntaxNode :top: AST to Text Scriban allows to write back an AST to a textual representation: var template = Template . Parse ( \"This is a {{ name }} template\" ); // Prints \"This is a {{name}} template\" Console . WriteLine ( template . ToText ()); In the previous example, you can notice that whitespace were removed from the original template. The reason is by default, the parser doesn't keep all hidden symbols when parsing, to still allow fast parsing for the regular case. But you can specify the parser to keep all the hidden symbols from the original template, directly by activating the IsKeepTrivia on the LexerOptions In the following example, you can see that it keep all the whitespace and comment: // Specifying the KeepTrivia allow to keep as much as hidden symbols from the original template (white spaces, newlines...etc.) var template = Template . Parse ( @\"This is a {{ name + ## With some comment ## '' }} template\" , lexerOptions : new LexerOptions () { KeepTrivia = true }); // Prints \"This is a {{ name + ## With some comment ## '' }} template\" Console . WriteLine ( template . ToText ()); :top: Extending TemplateContext You may need to extend a TemplateContext to overrides some methods there, tyically in cases you want: To hook into whenever a ScriptNode AST node is evaluated To catch if a property/member is accessed and should not be null Provides a IObjectAccessor for non .NET, non Dictionary<string, object> in case you are looking to expose a specific object to the runtime that requires a specific access pattern. By overriding the method GetMemberAccessorImpl you can override this aspect. To override ToString(span, object) method to provide custom ToString for specifics .NET objects. ...etc. :top: ScriptObject advanced usages It is sometimes required for a custom function to have access to the current TemplateContext or to tha access to original location of the text code, where a particular expression is occurring (via a SourceSpan that gives a line , column and sourcefile ) Advanced custom functions In the ScriptObject section we described how to easily import a custom function either by using a delegate or a pre-defined .NET static functions/properties. In some cases, you also need to have access to the current TemplateContext and also, the current SourceSpan (original location position in the text template code). By simply adding as a first parameter TemplateContext , and optionally as a second parameter, a SourceSpan a custom function can have access to the current evaluation context: var scriptObject1 = new ScriptObject (); // Here, we can have access to the `TemplateContext` scriptObject1 . Import ( \"contextAccess\" , new Func < TemplateContext , string >( templateContext => \"Yes\" )); :top: Hyper custom functions IScriptCustomFunction Some custom functions can require deeper access to the internals for exposing a function. Scriban provides the interface IScriptCustomFunction for this matter. If an object inherits from this interface and is accessed another ScriptObject , it will call the method IScriptCustomFunction.Invoke . namespace Scriban.Runtime { /// <summary> /// Allows to create a custom function object. /// </summary> public interface IScriptCustomFunction { /// <summary> /// Calls the custom function object. /// </summary> /// <param name=\"context\">The template context</param> /// <param name=\"callerContext\">The script node originating this call</param> /// <param name=\"parameters\">The parameters of the call</param> /// <param name=\"blockStatement\">The current block statement this call is made</param> /// <returns>The result of the call</returns> object Invoke ( TemplateContext context , ScriptNode callerContext , ScriptArray parameters , ScriptBlockStatement blockStatement ); } } As you can see, the IScriptCustomFunction gives you access to: The current TemplateContext evaluating the current Template The AST node context from the Template that is calling this custom functions, so you can precisely get information about the location of the parameters in the original source code...etc. The parameters already evaluated The block statement (not yet used for custom functions - but used by the wrap statement) The include expression is typically implemented via a IScriptCustomFunction . You can have a look at the details here :top: Evaluating an expression It is sometimes convenient to evaluate a script expression without rendering it to a string. First, there is an option in TemplateContext.EnableOutput that can be set to disable the output to the TemplateContext.Output StringBuilder. Also, as in the Abstract Syntax Tree section, all AST ScriptNode have an Evaluate method that returns the result of an evaluation. Lastly, you can use the convenient static method Template.Evaluate to quickly evaluate an expression relative to a TemplateContext : var scriptObject1 = new ScriptObject (); scriptObject1 . Add ( \"var1\" , 5 ); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var result = Template . Evaluate ( \"var1 * 5 + 2\" , context ); // Prints `27` Console . WriteLine ( result ); When using Template.Evaluate , the underlying code will use the ScriptMode.ScriptOnly when compiling the expression and will disable the output on the TemplateContext . :top: Changing the Culture The default culture when running a template is CultureInfo.InvariantCulture You can change the culture that is used when rendering numbers/date/time and parsing date/time by pushing a new Culture to a TemplateContext var context = new TemplateContext (); context . PushCulture ( CultureInfo . CurrentCulture ); // ... context . PopCulture (); Notice that the parsing of numbers in the language is not culture dependent but is baked into the language specs instead. :top: Safe Runtime The TemplateContext provides a few properties to control the runtime and make it safer. You can tweak the following properties: LoopLimit (default is 1000 ): If a script performs a loop over 1000 iteration, the runtime will throw a ScriptRuntimeException RecursiveLimit (default is 100 ): If a script performs a recursive call over 100 depth, the runtime will throw a ScriptRuntimeException StrictVariables (default is false ): If set to true , any variables that were not found during variable resolution will throw a ScriptRuntimeException RegexTimeOut (default is 10s ): If a builtin function is using a regular expression that is taking more than 10s to complete, the runtime will throw an exception :top:","title":"Runtime"},{"location":"runtime/#runtime","text":"This document describes the runtime API to manipulate scriban text templating. Scriban provides a safe runtime , meaning it doesn't expose any .NET objects that haven't been made explicitly available to a Template. The runtime is composed of two main parts: The parsing/compiler infrastructure that is responsible for parsing a text template and build a runtime representation of it (we will call this an Abstract Syntax Tree ) The rendering/evaluation infrastructure that is responsible to render a compiled template to a string. We will see also that we can evaluate expressions without rendering. The scriban runtime was designed to provide an easy, powerful and extensible infrastructure. For example, we are making sure that nothing in the runtime is using a static, so that you can correctly override all the behaviors of the runtime. Parsing a template Parsing modes Parsing languages Liquid support Rendering a template Overview The TemplateContext execution model The ScriptObject Accessing as regular dictionary objects Imports a .NET delegate Imports functions from a .NET class Automatic functions import from ScriptObject Function arguments, optional and params Accessing nested ScriptObject Imports a ScriptObject into another ScriptObject Imports a .NET object instance Accessing a .NET object read-only properties The builtin functions The stack of ScriptObject The with statement with the stack Advanced usages Member renamer Member filter Include and ITemplateLoader The Lexer and Parser Abstract Syntax Tree AST to Text Extending TemplateContext ScriptObject advanced usages Advanced custom functions Hyper custom functions IScriptCustomFunction Evaluating an expression Changing the Culture Safe Runtime :top:","title":"Runtime"},{"location":"runtime/#parsing-a-template","text":"The Scriban.Template class is a main entry point to easily parse a template and renders it. The action of parsing consist of compiling the template to a faster runtime representation, suitable later for rendering the template. This class is mostly a user friendly frontend to the underlying classes used to parse a template. See The Lexer and Parser section for advanded usages. The Template.Parse method is a convenient method to parse a template from a string and returns the compiled Template: var inputTemplateAsText = \"This is a {{ name }} template\" ; // Parse the template var template = Template . Parse ( inputTemplateAsText ); // Check for any errors if ( template . HasErrors ) { foreach ( var error in template . Messages ) { Console . WriteLine ( error ); } return ; // or throw...etc. } The returned Template object has the following relevant properties: ScriptPage Page {get;} that contains the compiled template to a root Abstract Syntax Tree (AST). From this object you can navigate through all the statements parsed from the template if necessary. See the section about the Abstract Syntax Tree bool HasErrors {get;} to check if the parsed template has any errors. In that case, the ScriptPage Page property is null . List<LogMessage> Messages {get;} contains the list of warning and error messages while parsing the template. If you are using the Template.Parse method, it is important to verify HasErrors is false , otherwise you will get a null ScriptPage object from the Template.Page property. The parse method can take an additional argument sourceFilePath used when reporting syntax errors, typically used to associate a template file read from the disk or an editor and you want to report the exact error to the user. // Parse the template var template = Template . Parse ( File . ReadAllText ( filePath ), filePath ); Note that the sourceFilePath is not used for accessing the disk (it could be a logical path to a zip file, or the name of tab opened in an editor...etc.). It is only a logical name that is used when reporting errors, but also you will see with the include directive and the setup of the Template Loader that this value can be used to perform an include operation in the relative context to the template path being processed. :top:","title":"Parsing a template"},{"location":"runtime/#parsing-modes","text":"By default, when parsing a template, the template is expected to have mixed content of text and scriban code blocks enclosed by {{ and }} . But you can modify the way a template is parsed by passing a LexerOptions to the Template.Parse method. The parsing mode is defined by the LexerOptions.Mode property which is ScriptMode.Default by default (i.e. mixed text and code). But you can also parse a template that contains directly scripting code (without enclosing {{ }} ), in that case, you can use the ScriptMode.ScriptOnly mode. For example illustrate how to use the ScriptOnly mode: // Create a template in ScriptOnly mode var lexerOptions = new LexerOptions () { Mode = ScriptMode . ScriptOnly }; // Notice that code is not enclosed by `{{` and `}}` var template = Template . Parse ( \"y = x + 1; y;\" , lexerOptions : lexerOptions ); // Renders it with the specified parameter var result = template . Evaluate ( new { x = 10 }); // Prints 11 Console . WriteLine ( result ); :top:","title":"Parsing modes"},{"location":"runtime/#parsing-languages","text":"Scriban provides 3 languages through the ScriptLang enum: ScriptLang.Default : which is the default Scriban Language ScriptLang.Liquid : which is used to parse the language with liquid syntax. ScriptLang.Scientific : which is similar to the default, but handles expression slight differently: Arguments separated by a space will convert to a multiplication: 2 x will be evaluated as 2 * x Except if a function is taking one argument, and in that case it resolves to a function call cos x resolves to cos(x) Otherwise function calls need to use explicit parenthesis myfunction(1,2,3) The language is defined by the LexerOptions.Lang property which. For example illustrate how to use the the ScriptLang.Scientific and the ScriptOnly mode: // Create a template in ScriptOnly mode var lexerOptions = new LexerOptions () { Lang = ScriptLang . Scientific , Mode = ScriptMode . ScriptOnly }; // Notice that code is not enclosed by `{{` and `}}` var template = Template . Parse ( \"y = x + 1; 2y;\" , lexerOptions : lexerOptions ); // Renders it with the specified parameter var result = template . Evaluate ( new { x = 10 }); // Prints 22 Console . WriteLine ( result ); :top:","title":"Parsing languages"},{"location":"runtime/#liquid-support","text":"Scriban supports a Lexer and Parser that can understand a Liquid template instead, while still translating it to a Scriban Runtime AST. You can easily parse an existing liquid template using the Template.ParseLiquid method: // An Liquid var inputTemplateAsText = \"This is a {{ name }} template\" ; // Parse the template var template = Template . ParseLiquid ( inputTemplateAsText ); // Renders the template with the variable `name` exposed to the template var result = template . Render ( new { name = \"Hello World\" }); // Prints the result: \"This is a Hello World template\" Console . WriteLine ( result ); Also, in terms of runtime, Liquid builtin functions are supported. They are created with the LiquidTemplateContext which inherits from the TemplateContext . :top:","title":"Liquid support"},{"location":"runtime/#rendering-a-template","text":"","title":"Rendering a template"},{"location":"runtime/#overview","text":"In order to render a template, you need pass a context for the variables, objects, functions that will be accessed by the template. In the following examples, we have a variable name that is used by the template: var inputTemplateAsText = \"This is a {{ name }} template\" ; // Parse the template var template = Template . Parse ( inputTemplateAsText ); // Renders the template with the variable `name` exposed to the template var result = template . Render ( new { name = \"Hello World\" }); // Prints the result: \"This is a Hello World template\" Console . WriteLine ( result ); As we can see, we are passing an anonymous objects that has this field/property name and by calling the Render method, the template is executed with this data model context. While passing an anonymous object is nice for a hello world example, it is not always enough for more advanced data model scenarios. In this case, you want to use more directly the TemplateContext (used by the method Template.Render(object) ) and a ScriptObject which are both at the core of scriban rendering architecture to provide more powerful constructions & hooks of the data model exposed (variables but also functions...etc.). :top:","title":"Overview"},{"location":"runtime/#the-templatecontext-execution-model","text":"The TemplateContext provides: an execution context when evaluating a template. The same instance can be used with many different templates, depending on your requirements. A stack of ScriptObject that provides the actual variables/functions accessible to the template, accessible through Template.PushGlobal(scriptObj) and Template.PopGlobal() . Why a stack and how to use this stack is described below. The text output when evaluating a template, which is accessible through the Template.Output property as a StringBuilder but because you can have nested rendering happening, it is possible to use Template.PushOutput() and Template.PopOutput() to redirect temporarily the output to a new output. This functionality is typically used by the capture statement . Caching of templates previously loaded by an include directive (see include and ITemplateLoader section ) Various possible overrides to allow fine grained extensibility (evaluation of an expression, conversion to a string, enter/exit/step into a loop...etc.) Note that a TemplateContext is not thread safe, so it is recommended to have one TemplateContext per thread. :top:","title":"The TemplateContext execution model"},{"location":"runtime/#the-scriptobject","text":"The ScriptObject is a special implementation of a Dictionary<string, object> that runtime properties and functions accessible to a template:","title":"The ScriptObject"},{"location":"runtime/#the-stack-of-scriptobject","text":"A TemplateContext maintains a stack of ScriptObject that defines the state of the variables accessible from the current template. When evaluating a template and resolving a variable , the TemplateContext will lookup to the stack of ScriptObject for the specified variable. From the top of the stack (the latest PushGlobal ) to the bottom of the stack, when a variable is accessed from a template, the closest variable in the stack will be returned. By default, the TemplateContext is initialized with a builtin ScriptObject which contains all the default builtin functions provided by scriban. You can pass your own builtin object if you want when creating a new TemplateContext . Then, each time you do a TemplateContext.PushGlobal(scriptObject) , you push a new ScriptObject accessible for resolving variable Let's look at the following example: // Creates scriptObject1 var scriptObject1 = new ScriptObject (); scriptObject1 . Add ( \"var1\" , \"Variable 1\" ); scriptObject1 . Add ( \"var2\" , \"Variable 2\" ); // Creates scriptObject2 var scriptObject2 = new ScriptObject (); // overrides the variable \"var2\" scriptObject2 . Add ( \"var2\" , \"Variable 2 - from ScriptObject 2\" ); // Creates a template with (builtins) + scriptObject1 + scriptObject2 variables var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); context . PushGlobal ( scriptObject2 ); var template = Template . Parse ( \"This is var1: `{{var1}}` and var2: `{{var2}}\" ); var result = template . Render ( context ); // Prints: \"This is var1: `Variable 1` and var2: `Variable 2 - from ScriptObject 2\" Console . WriteLine ( result ); The TemplateContext stack is setup like this: scriptObject2 => scriptObject1 => builtins As you can see the variable var1 will be resolved from scriptObject1 but the variable var2 will be resolved from scriptObject2 as there is an override here. NOTE If a variable is not found, the runtime will not throw an error but will return null instead. It allows to check for a variable existence if !page for example. In case you want your script to throw an exception if a variable was not found, you can specify TemplateContext.StrictVariables = true to enforce checks. See the safe runtime section for more details. When writing to a variable, only the ScriptObject at the top of the TemplateContext will be used. This top object is accessible through TemplateContext.CurrentGlobal property. It the previous example, if we had something like this in a template: var template2 = Template . Parse ( \"This is var1: `{{var1}}` and var2: `{{var2}}`{{var2 = 5}} and new var2: `{{var2}}\" ); var result = template2 . Render ( context ); // Prints: \"This is var1: `Variable 1` and var2: `Variable 2 - from ScriptObject 2 and new var2: `5`\" Console . WriteLine ( result ); The scriptObject2 object will now contain the var2 = 5 The stack provides a way to segregate variables between their usages or read-only/accessibility/mutability requirements. Typically, the builtins ScriptObject is a normal ScriptObject that contains all the builtins objects but you cannot modify directly the builtins object. But you could modify the sub-builtins objects. For example, the following code adds a new property myprop to the builtin object string : {{ string.myprop = \"Yoyo\" }} Because scriban allows you to define new functions directly into the language and also allow to store a function pointer by using the alias @ operator, you can basically extend an existing object with both properties and functions.","title":"The stack of ScriptObject"},{"location":"runtime/#advanced-usages","text":"","title":"Advanced usages"},{"location":"runtime/#member-renamer","text":"By default, .NET objects accessed through a ScriptObject are automatically exposed with lowercase and _ names. It means that a property like MyMethodIsNice will be exposed as my_method_is_nice . This is the default convention, originally to match the behavior of liquid templates. A renamer is simply a delegate that takes an input MemberInfo and return a new member name: namespace Scriban.Runtime { public delegate string MemberRenamerDelegate ( MemberInfo member ); } The StandardMemberRenamer is used to convert string camel/pascal case strings to \"ruby\" like strings. If you want to import a .NET object without changing the cases, you can use the simple nop member renamer member => member.Name . Note that renaming can be changed at two levels: When importing a .NET object into a ScriptObject by passing a renamer delegate, before passing an object to a TemplateContext : var scriptObject1 = new ScriptObject (); // Here the renamer will just return a same member name as the original // hence importing .NET member name as-is scriptObject1 . Import ( new MyObject (), renamer : member => member . Name ); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var template = Template . Parse ( \"This is Hello: `{{Hello}}`\" ); var result = template . Render ( context ); // Prints This is MyFunctions.Hello: `hello from method!` Console . WriteLine ( result ); - By setting the default member renamer on the TemplateContext // Setup a default renamer at the `TemplateContext` level var context = new TemplateContext { MemberRenamer = member => member . Name }; It is important to setup this on the TemplateContext for any .NET objects that might be accessed indirectly through another ScriptObject so that when a .NET object is exposed, it is exposed with the correct naming convention. The method Template.Render(object, renamer) takes also a member renamer, imports the object model with the renamer and setup correctly the renamer on the underlying TemplateContext . So you can rewrite the previous example with the shorter version: var template = Template . Parse ( \"This is Hello: `{{Hello}}`\" ); template . Render ( new MyObject (), member => member . Name ); :top:","title":"Member renamer"},{"location":"runtime/#member-filter","text":"Similar to the member renamer, by default, .NET objects accessed through a ScriptObject are automatically exposing all public instance fields and properties of .NET objects. A filter is simply a delegate that takes an input MemberInfo and return a boolean to indicate whether to expose the member ( true ) or discard the member ( false ) namespace Scriban.Runtime { /// <summary> /// Allows to filter a member while importing a .NET object into a ScriptObject /// or while exposing a .NET instance through a ScriptObject, /// by returning <c>true</c> to keep the member; or false to discard it. /// </summary> /// <param name=\"member\">A member info</param> /// <returns><c>true</c> to keep the member; otherwise <c>false</c> to remove the member</returns> public delegate bool MemberFilterDelegate ( MemberInfo member ); } You can use a MemberFilter when importing a an instance: var scriptObject1 = new ScriptObject (); // Imports only properties that contains the word \"Yo\" scriptObject1 . Import ( new MyObject (), filter : member => member is PropertyInfo && member . Name . Contains ( \"Yo\" )); - By setting the default member filter on the TemplateContext , so that .NET objects automatically exposed via a ScriptObject will follow the global filtering rules defined on the context: // Setup a default filter at the `TemplateContext` level var context = new TemplateContext { MemberFilter = member => member is PropertyInfo && member . Name . Contains ( \"Yo\" ) }; As for the member renamer, it is important to setup this on the TemplateContext for any .NET objects that might be accessed indirectly through another ScriptObject so that when a .NET object is exposed, it is exposed with the same filtering convention :top:","title":"Member filter"},{"location":"runtime/#include-and-itemplateloader","text":"The include directives requires that a template loader is setup on the TemplateContext.TemplateLoader property A template loader is responsible for providing the text template from an include directive. The interface of a ITemplateLoader is defined like this: /// <summary> /// Interface used for loading a template. /// </summary> public interface ITemplateLoader { /// <summary> /// Gets an absolute path for the specified include template name. Note that it is not necessarely a path on a disk, /// but an absolute path that can be used as a dictionary key for caching) /// </summary> /// <param name=\"context\">The current context called from</param> /// <param name=\"callerSpan\">The current span called from</param> /// <param name=\"templateName\">The name of the template to load</param> /// <returns>An absolute path or unique key for the specified template name</returns> string GetPath ( TemplateContext context , SourceSpan callerSpan , string templateName ); /// <summary> /// Loads a template using the specified template path/key. /// </summary> /// <param name=\"context\">The current context called from</param> /// <param name=\"callerSpan\">The current span called from</param> /// <param name=\"templatePath\">The path/key previously returned by <see cref=\"GetPath\"/></param> /// <returns>The content string loaded from the specified template path/key</returns> string Load ( TemplateContext context , SourceSpan callerSpan , string templatePath ); } In order to use the include directive, the template loader should provide: The GetPath method translates a templateName (the argument passed to the include <templateName> directive) to a logical/phyisical path that the ITemplateLoader.Load method will understand. The Load method to actually load the the text template code from the specified templatePath (previously returned by GetPath method) The 2 step methods, GetPath and then Load allows to cache intermediate results. If a template loader returns the same template path for a template name any existing cached templates will be returned instead. Cached templates are stored in the TemplateContext.CachedTemplates property. A typical implementation of ITemplateLoader could read data from the disk: ``` C # /// <summary> /// A very simple ITemplateLoader loading directly from the disk, without any checks...etc. /// </summary> public class MyIncludeFromDisk : ITemplateLoader { string GetPath ( TemplateContext context , SourceSpan callerSpan , string templateName ) { return Path . Combine ( Environment . CurrentDirectory , templateName ); } string Load ( TemplateContext context , SourceSpan callerSpan , string templatePath ) { // Template path was produced by the `GetPath` method above in case the Template has // not been loaded yet return File . ReadAllText ( templatePath ); } } :top:","title":"Include and ITemplateLoader"},{"location":"runtime/#the-lexer-and-parser","text":"The Lexer class is responsible for extracting Tokens from a text template. The Parser class is responsible for creating ScriptNode AST from input tokens (extracted from the Lexer ) The lexer has a few LexerOptions to control the way the lexer is behaving, as described with the parsing modes The parser has a ParserOptions only used for securing nested statements/blocks to avoid any stack overflow exceptions while parsing a document. :top:","title":"The Lexer and Parser"},{"location":"runtime/#abstract-syntax-tree","text":"The base object used by the syntax for all scriban elements is the class Scriban.Syntax.ScriptNode : /// <summary> /// Base class for the abstract syntax tree of a scriban program. /// </summary> public abstract class ScriptNode { /// <summary> /// The source span of this node. /// </summary> public SourceSpan Span ; /// <summary> /// Evaluates this instance with the specified context. /// </summary> /// <param name=\"context\">The template context.</param> public abstract object Evaluate ( TemplateContext context ); } As you can see, each ScriptNode contains a method to evaluate it against a TemplateContext . You can go through the all the Syntax classes in the codebase and you will see that it is very easy to create a new SyntaxNode :top:","title":"Abstract Syntax Tree"},{"location":"runtime/#extending-templatecontext","text":"You may need to extend a TemplateContext to overrides some methods there, tyically in cases you want: To hook into whenever a ScriptNode AST node is evaluated To catch if a property/member is accessed and should not be null Provides a IObjectAccessor for non .NET, non Dictionary<string, object> in case you are looking to expose a specific object to the runtime that requires a specific access pattern. By overriding the method GetMemberAccessorImpl you can override this aspect. To override ToString(span, object) method to provide custom ToString for specifics .NET objects. ...etc. :top:","title":"Extending TemplateContext"},{"location":"runtime/#scriptobject-advanced-usages","text":"It is sometimes required for a custom function to have access to the current TemplateContext or to tha access to original location of the text code, where a particular expression is occurring (via a SourceSpan that gives a line , column and sourcefile )","title":"ScriptObject advanced usages"},{"location":"runtime/#evaluating-an-expression","text":"It is sometimes convenient to evaluate a script expression without rendering it to a string. First, there is an option in TemplateContext.EnableOutput that can be set to disable the output to the TemplateContext.Output StringBuilder. Also, as in the Abstract Syntax Tree section, all AST ScriptNode have an Evaluate method that returns the result of an evaluation. Lastly, you can use the convenient static method Template.Evaluate to quickly evaluate an expression relative to a TemplateContext : var scriptObject1 = new ScriptObject (); scriptObject1 . Add ( \"var1\" , 5 ); var context = new TemplateContext (); context . PushGlobal ( scriptObject1 ); var result = Template . Evaluate ( \"var1 * 5 + 2\" , context ); // Prints `27` Console . WriteLine ( result ); When using Template.Evaluate , the underlying code will use the ScriptMode.ScriptOnly when compiling the expression and will disable the output on the TemplateContext . :top:","title":"Evaluating an expression"},{"location":"runtime/#changing-the-culture","text":"The default culture when running a template is CultureInfo.InvariantCulture You can change the culture that is used when rendering numbers/date/time and parsing date/time by pushing a new Culture to a TemplateContext var context = new TemplateContext (); context . PushCulture ( CultureInfo . CurrentCulture ); // ... context . PopCulture (); Notice that the parsing of numbers in the language is not culture dependent but is baked into the language specs instead. :top:","title":"Changing the Culture"},{"location":"runtime/#safe-runtime","text":"The TemplateContext provides a few properties to control the runtime and make it safer. You can tweak the following properties: LoopLimit (default is 1000 ): If a script performs a loop over 1000 iteration, the runtime will throw a ScriptRuntimeException RecursiveLimit (default is 100 ): If a script performs a recursive call over 100 depth, the runtime will throw a ScriptRuntimeException StrictVariables (default is false ): If set to true , any variables that were not found during variable resolution will throw a ScriptRuntimeException RegexTimeOut (default is 10s ): If a builtin function is using a regular expression that is taking more than 10s to complete, the runtime will throw an exception :top:","title":"Safe Runtime"}]}